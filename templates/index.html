<!-- VERSION: 2024-12-19-revised -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Braille Plate & Cylinder STL Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="./static/favicon.svg" type="image/svg+xml">
    <base href="/braille-card-and-cylinder-stl-generator-githubpages/">
    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./static/three.module.js",
                "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.6?module",
                "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.17?module"
            },
            "scopes": {
                "https://unpkg.com/": {
                    "three": "./static/three.module.js"
                }
            }
        }
    </script>
    <style>
        /* Theme CSS Variables */
        :root {
            /* Light mode colors */
            --bg-gradient-start: #e0e7ff;
            --bg-gradient-end: #f6f8fa;
            --bg-primary: #fff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-input: #f9fafb;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-tertiary: #666;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --border-focus: #3182ce;
            --btn-primary-bg: linear-gradient(90deg, #3182ce 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #2563eb 60%, #4299e1 100%);
            --btn-success-bg: #10b981;
            --btn-success-hover-bg: #059669;
            --btn-secondary-bg: #9ca3af;
            --btn-tertiary-bg: #6b7280;
            --error-bg: #fee2e2;
            --error-border: #fecaca;
            --error-text: #b91c1c;
            --info-bg: #dbeafe;
            --info-border: #93c5fd;
            --info-text: #1e40af;
            --shadow-light: rgba(49,130,206,0.10);
            --shadow-medium: rgba(49,130,206,0.18);
            --stl-mesh-color: #6699cc;
            --stl-background: #f1f5f9;
            --stl-ambient-light: #888888;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.5;
            --stl-directional-intensity: 1.0;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-gradient-start: #1a202c;
            --bg-gradient-end: #2d3748;
            --bg-primary: #2d3748;
            --bg-secondary: #374151;
            --bg-tertiary: #4a5568;
            --bg-input: #374151;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-primary: #4a5568;
            --border-secondary: #718096;
            --border-focus: #63b3ed;
            --btn-primary-bg: linear-gradient(90deg, #4299e1 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #3182ce 60%, #4299e1 100%);
            --btn-success-bg: #059669;
            --btn-success-hover-bg: #047857;
            --btn-secondary-bg: #718096;
            --btn-tertiary-bg: #4a5568;
            --error-bg: #742a2a;
            --error-border: #9b2c2c;
            --error-text: #fed7d7;
            --info-bg: #2c5282;
            --info-border: #3182ce;
            --info-text: #bee3f8;
            --shadow-light: rgba(0,0,0,0.3);
            --shadow-medium: rgba(0,0,0,0.5);
            --stl-mesh-color: #90cdf4;
            --stl-background: #2d3748;
            --stl-ambient-light: #666666;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.6;
            --stl-directional-intensity: 0.9;
        }

        /* High contrast mode */
        [data-theme="high-contrast"] {
            --bg-gradient-start: #000000;
            --bg-gradient-end: #000000;
            --bg-primary: #000000; /* Keep black background */
            --bg-secondary: #1a1a1a; /* Keep dark background */
            --bg-tertiary: #2a2a2a; /* Keep dark background */
            --bg-input: #1a1a1a; /* Keep dark background for inputs */
            --text-primary: #02fe05; /* Green instead of white */
            --text-secondary: #02fe05; /* Green instead of white */
            --text-tertiary: #02fe05; /* Green instead of white */
            --border-primary: #ffff00;
            --border-secondary: #00ffff;
            --border-focus: #ff00ff;
            --btn-primary-bg: #02fe05; /* Green */
            --btn-primary-hover-bg: #02fe05; /* Green */
            --btn-success-bg: #02fe05; /* Green */
            --btn-success-hover-bg: #02fe05; /* Green */
            --btn-secondary-bg: #ff6600;
            --btn-tertiary-bg: #ff6600;
            --error-bg: #ff0000;
            --error-border: #ff0000;
            --error-text: #02fe05; /* Green instead of white */
            --info-bg: #0000ff;
            --info-border: #0000ff;
            --info-text: #02fe05; /* Green instead of white */
            --shadow-light: none;
            --shadow-medium: none;
            --stl-mesh-color: #00ffff; /* Bright cyan for high contrast */
            --stl-background: #000000; /* Keep black background */
            --stl-ambient-light: #666666; /* Reduced ambient light to prevent washing out */
            --stl-directional-light: #e6e6e6; /* Slightly dimmed directional light for better contrast */
            --stl-ambient-intensity: 0.4; /* Lower ambient light intensity */
            --stl-directional-intensity: 0.8; /* Controlled directional light intensity */
        }

        /* High contrast mode specific button styling */
        [data-theme="high-contrast"] button[type="submit"] {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] button[type="submit"]:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Generate STL button state (blue) */
        [data-theme="high-contrast"] #action-btn.generate-state {
            background: #0201fe !important; /* Blue background for generate */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #fdfe00 !important; /* Yellow border */
        }
        
        [data-theme="high-contrast"] #action-btn.generate-state:hover {
            background: #0201fe !important; /* Blue background */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #02fe05 !important; /* Green border on hover */
        }
        
        /* High contrast mode - Download STL button state (green) */
        [data-theme="high-contrast"] #action-btn.download-state {
            background: #02fe05 !important; /* Green background for download */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }
        
        [data-theme="high-contrast"] #action-btn.download-state:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Disabled/Loading state */
        [data-theme="high-contrast"] #action-btn:disabled {
            background: #666666 !important; /* Gray background for disabled */
            color: #cccccc !important; /* Light gray text */
            border: 2px solid #999999 !important; /* Gray border */
            cursor: not-allowed !important;
        }

        [data-theme="high-contrast"] #download-counter-plate-btn {
            background: #ff6600 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #download-counter-plate-btn:hover {
            background: #ff8800 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        [data-theme="high-contrast"] .expert-toggle-btn,
        [data-theme="high-contrast"] .info-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn:hover,
        [data-theme="high-contrast"] .info-toggle-btn:hover {
            background: #000000 !important; /* Black background on hover */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn.active,
        [data-theme="high-contrast"] .info-toggle-btn.active {
            background: #000000 !important; /* Black background when active */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .font-size-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .font-size-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        [data-theme="high-contrast"] .font-size-btn.reset-btn {
            background: #2a2a2a !important; /* Darker background */
            color: #00ffff !important; /* Cyan text */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .font-size-display {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        /* Apply transition to theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; /* Ensure all elements include padding/borders in width */
        }

        /* Skip Link for Keyboard Navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--border-focus);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 8px 0;
            z-index: 1000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }



        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.4em 0.6em;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .font-size-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px var(--shadow-medium);
        }

        .font-size-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .font-size-btn.reset-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        .font-size-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 3.5em;
            text-align: center;
            user-select: none;
        }



        /* Enhanced focus indicators for all interactive elements */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Ensure proper keyboard navigation visibility */
        *:focus-visible {
            outline: 3px solid var(--border-focus) !important;
            outline-offset: 2px !important;
        }

        /* Mobile-optimized scroll containers */
        @media (max-width: 768px) {
            .main-layout {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                max-height: calc(100vh - 1em);
            }
            
            /* Sticky generate button on mobile */
            .button-row {
                position: sticky;
                bottom: 0;
                background: var(--bg-primary);
                padding: 1em 0;
                margin: 0 -1em;
                padding-left: 1em;
                padding-right: 1em;
                box-shadow: 0 -2px 8px var(--shadow-light);
                z-index: 10;
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Fieldset styling */
        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        .line-input-fieldset {
            margin: 0;
        }

        /* Braille preview styles */
        .braille-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
        }

        .preview-heading {
            margin-top: 0;
            color: var(--text-primary);
        }

        .preview-line-success {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            border: 1px solid var(--border-primary);
        }

        .preview-line-error {
            margin: 10px 0;
            padding: 10px;
            background: var(--error-bg);
            border-radius: 5px;
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }

        .expert-info {
            font-size: 0.9em;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 1em;
            text-align: center;
        }

        /* High contrast text styling */
        [data-theme="high-contrast"] strong,
        [data-theme="high-contrast"] b {
            color: #02fe05 !important; /* Green for bold text */
        }

        [data-theme="high-contrast"] .grade-label[style*="font-weight: 700"] {
            color: #02fe05 !important; /* Green for bold labels */
        }

        [data-theme="high-contrast"] em,
        [data-theme="high-contrast"] i,
        [data-theme="high-contrast"] [style*="font-style: italic"] {
            color: #fdfe00 !important; /* Yellow for italic text */
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-info span {
            color: #fdfe00 !important; /* Yellow for grade info notes */
        }

        [data-theme="high-contrast"] #offset-help {
            color: #fdfe00 !important; /* Yellow for offset help text */
        }

        /* Note styling classes */
        .grade-note,
        .offset-note {
            color: var(--text-tertiary);
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-note,
        [data-theme="high-contrast"] .offset-note {
            color: #fdfe00 !important; /* Yellow for all note text */
        }

        body {
            background: linear-gradient(120deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            font-family: 'Inter', system-ui, Arial, sans-serif;
            margin: 0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 2em;
            color: var(--text-primary);
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* Mobile-specific body adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5em;
                min-height: 100vh;
                overflow-x: hidden;
            }
        }
        
        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 2em;
            background: var(--bg-primary);
            border-radius: 22px;
            box-shadow: 0 8px 32px var(--shadow-light);
            padding: 2.5em 2.5em 2.5em 2.5em;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            overflow-x: hidden; /* Prevent horizontal overflow */
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        /* Mobile layout optimization */
        @media (max-width: 768px) {
            .main-layout {
                padding: 1.5em;
                border-radius: 16px;
                gap: 1.5em;
                box-shadow: 0 4px 16px var(--shadow-light);
            }
        }
        
        @media (max-width: 480px) {
            .main-layout {
                padding: 1em;
                border-radius: 12px;
                gap: 1em;
            }
        }
        
        /* Title Section - Full Width at Top */
        .title-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1.5em;
            width: 100%;
        }
        
        .title-section h1 {
            margin: 0;
            display: flex;
            flex-direction: column;
            line-height: 1.1;
        }
        
        .title-line-1 {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--text-primary); /* Default theme color */
        }
        
        .title-line-2 {
            font-size: 1.6em;
            font-weight: 600;
            color: var(--text-secondary); /* Default theme color */
            margin-top: 0.1em;
        }
        
        /* High contrast mode - bright violet title */
        [data-theme="high-contrast"] .title-line-1,
        [data-theme="high-contrast"] .title-line-2 {
            color: #fd01fc !important; /* Bright violet for high contrast mode */
        }
        
        /* Top Accessibility Controls */
        .accessibility-controls-top {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
            margin-left: 1rem;
        }
        
        /* Content Area - Two Column Layout */
        .content-area {
            display: flex;
            gap: 2.5em;
            width: 100%;
        }
        
        /* Left Column - Preview Section (45% width) */
        .preview-section {
            flex: 0 0 45%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            overflow: visible; /* Ensure rounded corners aren't cut off */
            padding-right: 1em; /* Add padding to prevent cutoff */
        }
        
        /* Right Column - Form Section (55% width) */
        .form-section {
            flex: 0 0 calc(55% - 2em); /* Subtract padding to prevent overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 320px;
            max-width: calc(55% - 2em); /* Prevent form from extending past background */
            overflow-x: hidden; /* Prevent horizontal overflow */
        }
        
        /* Mobile layout - stack columns */
        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
                gap: 1.5em;
            }
            
            .preview-section,
            .form-section {
                flex: none;
                width: 100%;
            }
        }

        #viewer {
            width: calc(100% - 2px); /* Account for border width */
            min-width: 320px;
            max-width: calc(100% - 2px);
            height: 420px;
            border-radius: 18px;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 4px 24px var(--shadow-light);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 0 1.5em 0;
            transition: box-shadow 0.2s;
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden; /* Ensure content doesn't overflow rounded corners */
            box-sizing: border-box; /* Include border in size calculation */
        }
        
        /* Mobile viewer optimizations */
        @media (max-width: 768px) {
            #viewer {
                height: 280px;
                min-width: unset;
                width: 100%;
                max-width: 100%;
                border-radius: 12px;
                margin: 0 0 1em 0;
            }
        }
        
        @media (max-width: 480px) {
            #viewer {
                height: 240px;
            }
        }
        #viewer:focus-within, #viewer:active {
            box-shadow: 0 8px 32px var(--shadow-medium);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 0.7em;
            color: var(--text-primary);
            text-align: left;
        }
        
        /* Mobile heading optimization */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 0.5em;
                text-align: center;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                line-height: 1.3;
            }
        }
        .info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .info-panel p {
            margin: 0.3em 0;
        }
        .grade-selection {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
        }
        
        /* Mobile grade selection optimization */
        @media (max-width: 768px) {
            .grade-selection {
                padding: 1.2em;
                margin-bottom: 1.2em;
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.6em;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.6em;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            padding: 0.5em 0;
            margin: -0.5em 0;
        }
        
        /* Mobile radio option optimization */
        @media (max-width: 768px) {
            .radio-option {
                padding: 0.8em 0;
                font-size: 1em;
                gap: 0.8em;
            }
            
            .radio-option input[type="radio"] {
                width: 20px;
                height: 20px;
                min-width: 20px;
                min-height: 20px;
            }
        }
        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }
        .radio-text {
            cursor: pointer;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1.1em;
        }
        .line-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
        }
        .line-input {
            display: flex;
            align-items: center;
            gap: 0.8em;
        }
        
        /* Mobile line input optimization */
        @media (max-width: 768px) {
            .line-input {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5em;
            }
            
            .line-label {
                font-size: 0.95em;
                font-weight: 600;
                margin-bottom: 0.2em;
            }
        }
        .line-label {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 0.9em;
        }
        input[type="text"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* Mobile-friendly input styles */
        @media (max-width: 768px) {
            input[type="text"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
            }
        }
        input[type="text"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        /* Ensure number inputs are properly styled and functional */
        input[type="number"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            min-width: 80px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }
        
        /* Remove spinner buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Mobile-friendly number input styles */
        @media (max-width: 768px) {
            input[type="number"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
                width: 100%;
                min-width: unset;
            }
        }
        
        input[type="number"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        input[type="number"]:hover {
            border-color: var(--border-primary);
        }
        
        /* Language select dropdown styling */
        .language-select {
            width: 100%;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%23666" d="M0 0l6 6 6-6z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.8em center;
            background-size: 12px;
            padding-right: 2.5em;
        }
        
        /* Mobile select optimization */
        @media (max-width: 768px) {
            .language-select {
                padding: 1em;
                padding-right: 3em;
                font-size: 16px;
                min-height: 48px;
            }
        }
        
        .language-select:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        .language-select:hover {
            border-color: var(--border-primary);
        }
        
        /* High contrast mode select styling */
        [data-theme="high-contrast"] .language-select {
            background: #1a1a1a !important;
            color: #ffffff !important;
            border: 2px solid #ffff00 !important;
        }
        
        [data-theme="high-contrast"] .language-select:focus {
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 2px solid #ff00ff !important;
        }
        
        [data-theme="high-contrast"] .language-select option {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }
        
        [data-theme="high-contrast"] .language-select optgroup {
            background: #2a2a2a !important;
            color: #ffff00 !important;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            margin-top: 1em;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 0.7em 1em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            line-height: 1.2;
            white-space: nowrap;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        /* Mobile-friendly button styles */
        @media (max-width: 768px) {
            button {
                padding: 1em 1.2em;
                font-size: 1.1em;
                min-height: 48px;
                min-width: 48px;
            }
        }
        button[type="submit"] {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        button[type="submit"]:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        /* Action button state styles */
        #action-btn {
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-size: 0.95em;
        }
        
        #action-btn.generate-state {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.generate-state:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        #action-btn.download-state {
            background: var(--btn-success-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.download-state:hover {
            background: var(--btn-success-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            margin-bottom: 1em;
            flex-wrap: wrap;
        }
        
        /* Mobile button row optimization */
        @media (max-width: 768px) {
            .button-row {
                gap: 0.8em;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }


        #download-counter-plate-btn {
            background: var(--btn-tertiary-bg);
            color: #fff;
        }
        #download-counter-plate-btn:hover {
            background: var(--btn-tertiary-bg);
            opacity: 0.9;
            transform: translateY(-2px) scale(1.03);
        }
        #error-message {
            color: var(--error-text);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 0.7em 1em;
            margin-top: 0.5em;
            font-size: 1em;
            display: none;
            align-items: center;
            gap: 0.5em;
        }
        
        #error-message.info {
            color: var(--info-text);
            background: var(--info-bg);
            border: 1px solid var(--info-border);
        }
        
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        
        .expert-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5em;
            transition: background 0.2s, border-color 0.2s;
            width: 100%;
        }
        
        .expert-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        
        .expert-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }
        
        .expert-toggle-btn.active #expert-toggle-icon {
            transform: rotate(180deg);
        }
        
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        /* Ensure Expert Mode inputs are properly spaced and visible */
        .expert-settings .grade-selection {
            margin-bottom: 1em;
        }
        
        .expert-settings input[type="number"] {
            margin-top: 0.3em;
            margin-bottom: 0.5em;
        }
        
        .expert-settings label {
            display: block;
            margin-bottom: 0.3em;
            font-weight: 500;
            color: var(--text-primary);
        }
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        .info-dropdown {
            margin-bottom: 1.5em;
        }
        
        .info-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .info-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        
        .info-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .info-toggle-btn.active #info-toggle-text {
            color: #fff;
        }
        
        .info-toggle-btn.active #info-toggle-icon {
            transform: rotate(180deg);
        }
        
        .info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .info-content p {
            margin: 0.3em 0;
        }
        
        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .viewer-section, .form-section {
                max-width: 100%;
                min-width: unset;
            }
            
            .info-panel, .info-content {
                padding: 1.2em;
                font-size: 0.95em;
            }
            
            .info-toggle-btn, .expert-toggle-btn {
                padding: 1em;
                font-size: 1em;
                min-height: 48px;
            }
            
            #error-message {
                padding: 1em;
                font-size: 0.95em;
                margin: 0.8em 0;
            }
            
            .button-group {
                gap: 0.8em;
            }
            
            /* Ensure scroll behavior is smooth on mobile */
            html {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            .expert-settings input[type="number"] {
                width: 100%;
            }
            
            .font-size-controls {
                transform: scale(0.9);
                transform-origin: top right;
            }
        }
        

        
        /* Plate Selection Row Layout */
        .plate-selection-row {
            display: flex;
            align-items: flex-start;
            gap: 1.5em;
            margin-top: 1em;
        }
        
        .plate-type-selection {
            flex: 1;
            min-width: 250px;
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            flex-shrink: 0;
        }
        
        /* Mobile plate selection row optimization */
        @media (max-width: 768px) {
            .plate-selection-row {
                flex-direction: column;
                gap: 1em;
            }
            
            .plate-type-selection {
                min-width: unset;
                width: 100%;
            }
            
            .button-row {
                width: 100%;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }

        /* Theme Toggle Section */
        .theme-toggle-section {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin-left: auto;
        }

        .theme-label-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.3em;
            min-height: 2.5em;
            box-sizing: border-box;
        }

        .theme-label-text {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Theme Toggle Button */
        .theme-toggle-btn {
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .theme-toggle-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .theme-icon {
            font-size: 1.2em;
        }

        /* Mobile title section optimization */
        @media (max-width: 768px) {
            .title-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 1rem;
                margin-bottom: 1em;
            }
            
            .title-section h1 {
                text-align: center;
            }
            
            .title-line-1 {
                font-size: 1.5em;
            }
            
            .title-line-2 {
                font-size: 1.3em;
            }
            
            .accessibility-controls-top {
                margin-left: 0;
                align-items: center;
            }
            
            .theme-toggle-section {
                flex-direction: column;
                align-items: center;
                gap: 0.5em;
                margin-left: 0;
            }
            
            .theme-label-box {
                font-size: 0.85em;
                min-height: 2.2em;
            }
        }
        
        @media (max-width: 480px) {
            .title-line-1 {
                font-size: 1.3em;
            }
            
            .title-line-2 {
                font-size: 1.1em;
            }
        }
        
        /* Form Section Accessibility Controls */
        [data-theme="high-contrast"] .theme-label-box {
            background: #1a1a1a !important; /* Dark background for high contrast */
            border: 2px solid #ffff00 !important; /* Yellow border for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-label-text {
            color: #02fe05 !important; /* Green text for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow instead of yellow */
            color: #0201fe !important; /* Blue instead of black */
            border: 2px solid #0201fe !important; /* Blue instead of black */
        }

        [data-theme="high-contrast"] input[type="text"],
        [data-theme="high-contrast"] input[type="number"] {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] input[type="text"]:focus,
        [data-theme="high-contrast"] input[type="number"]:focus {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ff00ff !important; /* Magenta border on focus */
        }

        [data-theme="high-contrast"] .info-panel,
        [data-theme="high-contrast"] .grade-selection,
        [data-theme="high-contrast"] .info-content {
            background: #1a1a1a !important; /* Dark background for panels */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .braille-preview {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .preview-line-success {
            background: #2a2a2a !important; /* Darker background */
            color: #02fe05 !important; /* Green text for success */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .preview-line-error {
            background: #ff0000 !important;
            color: #02fe05 !important; /* Green text */
            border: 2px solid #ff0000 !important;
        }

        /* Section Title Styling - Larger Font for All Themes */
        .info-panel strong,
        .info-panel p strong {
            font-size: 1.3em !important;
            font-weight: 700 !important;
        }
        
        #info-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }
        
        .grade-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.8em;
            font-size: 1.2em !important; /* Increased from 0.9em */
        }
        
        .expert-toggle-btn #expert-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Keyboard Users -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to main content</a>
    

    
    <div class="main-layout" role="main" id="main-content">
        <!-- Title Section at the top -->
        <div class="title-section">
            <h1 id="main-heading">
                <span class="title-line-1">Braille Plate & Cylinder</span>
                <span class="title-line-2">STL Generator</span>
            </h1>
            
            <!-- Accessibility Controls in top right -->
            <div class="accessibility-controls-top" role="group" aria-label="Accessibility controls">
                <!-- Font Size Controls -->
                <div class="font-size-controls" role="group" aria-label="Font size adjustment">
                    <button id="font-decrease" class="font-size-btn" aria-label="Decrease font size" title="Decrease font size">
                        <span aria-hidden="true">A-</span>
                        <span class="sr-only">Decrease font size</span>
                    </button>
                    <span class="font-size-display" aria-label="Current font size">
                        <span id="current-font-size">100</span>%
                    </span>
                    <button id="font-increase" class="font-size-btn" aria-label="Increase font size" title="Increase font size">
                        <span aria-hidden="true">A+</span>
                        <span class="sr-only">Increase font size</span>
                    </button>
                    <button id="font-reset" class="font-size-btn reset-btn" aria-label="Reset font size to default" title="Reset font size to default">
                        <span aria-hidden="true">⟲</span>
                        <span class="sr-only">Reset font size</span>
                    </button>
                </div>
                
                <!-- Theme Toggle Section -->
                <div class="theme-toggle-section" role="group" aria-labelledby="theme-label">
                    <div id="theme-label" class="theme-label-box">
                        <span class="theme-label-text">Change Theme to →</span>
                    </div>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle theme" title="Toggle between light, dark, and high contrast themes">
                        <span class="theme-icon" aria-hidden="true">⚡</span>
                        <span class="theme-text">High Contrast</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area - Two Column Layout -->
        <div class="content-area">
            <!-- Left Column - STL Preview Section (45% width) -->
            <div class="preview-section" role="region" aria-label="3D STL Preview">
                <div id="viewer" role="img" aria-label="3D preview of braille STL model" tabindex="0"></div>
                
                <!-- Text Input Section moved here -->
                <div class="line-input-group">
                    <fieldset class="line-input-fieldset">
                        <legend class="grade-label">Enter Text for Braille Translation</legend>
                        <div class="grade-note" style="margin-bottom: 0.8em; font-size: 0.85em;">
                            <strong>Note:</strong> Contracted braille combines letters into single cells, so the character limit is only confirmed <em>after translation</em> — the program will warn you automatically if it's too long.
                        </div>
                        <!-- Dynamic line inputs container -->
                        <div id="dynamic-line-inputs">
                            <!-- Line inputs will be dynamically generated here based on grid_rows value -->
                        </div>
                    </fieldset>
                </div>
                
                <!-- Action Button moved here -->
                <div class="button-row" style="margin-top: 1em;">
                    <button type="button" id="action-btn" class="generate-state" aria-label="Generate STL file from entered text" data-state="generate">Generate STL</button>
                </div>
            </div>
            
            <!-- Right Column - Form Controls Section (55% width) -->
            <div class="form-section" role="region" aria-label="Braille Card Configuration">
                <div class="info-panel">
                    <p><strong>Program Description:</strong></p>
                    <p>This tool primarily generates <strong>cylindrical braille objects</strong> and matching plates. You can also produce flat business-card plates.</p>
                    <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                        <li><strong>Embossing Plate</strong> (raised/positive)</li>
                        <li><strong>Universal Counter Plate</strong> (recessed/negative)</li>
                    </ol>
                </div>
                
                <div class="info-dropdown">
                    <button type="button" id="info-toggle" class="info-toggle-btn">
                        <span id="info-toggle-text">More Info</span>
                        <span id="info-toggle-icon">▼</span>
                    </button>
                    <div id="info-content" class="info-content" style="display: none;">
                        <p><strong>Instructions (Cylinder-first workflow):</strong></p>
                        <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Enter up to <strong>4 lines</strong> of text. Click <strong>"Generate STL"</strong>. The app auto-translates to <strong>UEB</strong>.</li>
                            <li>Leave the <strong>Output Shape</strong> as <strong>Cylinder</strong> (default). Review the 3D preview, then <strong>Download STL</strong>.</li>
                            <li>If you also need the <strong>Universal Counter Plate</strong>, switch Plate to <strong>Counter Plate</strong> and generate once. You only need to download it again if you change <strong>Expert Mode</strong> settings that affect dot geometry or spacing. Translation changes only affect the embossing plate.</li>
                            <li>To make flat business-card plates instead, open <strong>Expert Mode</strong> → set <strong>Output Shape</strong> to <strong>Flat Card</strong>, then generate plates.</li>
                            <li>Use <strong>Expert Mode</strong> to adjust cylinder diameter/height, card dimensions, braille spacing, and dot sizes as needed.</li>
                        </ol>
                        <p><strong>Acknowledgements:</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Powered by <a href="https://liblouis.io/" target="_blank" style="color: #3182ce; text-decoration: none;"><strong>Liblouis</strong></a>, an open-source professional braille translator.</li>
                            <li>Extra thanks to <strong>Tobi Weinberg</strong> for the substantial time and effort he volunteered to help start this project and see it through.</li>
                        </ul>
                    </div>
                </div>
                
                <div id="error-message" role="alert" aria-live="assertive" aria-atomic="true">
                    <span style="font-weight:bold;" aria-hidden="true">⚠</span> 
                    <span id="error-text"></span>
                </div>
                
                <form id="braille-form" aria-labelledby="main-heading">
                    <!-- Language Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Language:</legend>
                            <div style="margin-bottom: 0.8em;">
                                <select id="language-table" name="language_table" class="language-select" aria-describedby="language-help">
                                    <option value="en-ueb-g2.ctb" selected>English, U.S., contracted (UEB grade 2)</option>
                                    <option value="en-ueb-g1.ctb">English, U.S., uncontracted (UEB grade 1)</option>
                                </select>
                                <div id="language-help" class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                    NOTE: English, U.S., contracted (UEB grade 2) is the default standard for all U.S. English braille translations. Please only select another language or grade for special use cases.
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                    <!-- Plate Type Selection moved here -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Plate to Generate</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="positive" checked aria-describedby="emboss-plate-desc">
                                    <span class="radio-text">Embossing Plate</span>
                                </label>
                                <span id="emboss-plate-desc" class="sr-only">Creates raised braille dots for embossing cards</span>
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="negative" aria-describedby="counter-plate-desc">
                                    <span class="radio-text">Universal Counter Plate</span>
                                </label>
                                <span id="counter-plate-desc" class="sr-only">Creates recessed dots to support embossing process</span>

                            </div>
                        </fieldset>
                    </div>
                    
                    <div class="expert-mode-toggle">
                        <button type="button" id="expert-toggle" class="expert-toggle-btn">
                            <span id="expert-toggle-text">Show Expert Mode</span>
                            <span id="expert-toggle-icon">▼</span>
                        </button>
                    </div>

                    <div id="expert-settings" class="expert-settings" style="display: none;">
                        <!-- Output Shape Selection (moved into Expert Mode) -->
                        <div class="grade-selection">
                            <fieldset>
                                <legend class="grade-label">Select Output Shape</legend>
                                <div class="radio-group" role="radiogroup" aria-required="true">
                                    <label class="radio-option">
                                        <input type="radio" name="shape_type" value="card" aria-describedby="card-shape-desc" aria-label="Flat Card shape">
                                        <span class="radio-text">Flat Card</span>
                                    </label>
                                    <span id="card-shape-desc" class="sr-only">Creates a flat rectangular braille card</span>
                                    <label class="radio-option">
                                        <input type="radio" name="shape_type" value="cylinder" checked aria-describedby="cylinder-shape-desc" aria-label="Cylinder shape">
                                        <span class="radio-text">Cylinder</span>
                                    </label>
                                    <span id="cylinder-shape-desc" class="sr-only">Creates a cylindrical braille surface</span>
                                </div>
                            </fieldset>
                        </div>

                        <div class="expert-info" role="note" aria-label="Expert mode information">
                            Any changes made here will affect both plates.
                        </div>
                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille Dimensions</label>
                            <div>
                                <label for="grid_columns" id="grid_columns_label">Number of Braille Cells (Characters):</label>
                                <input type="number" id="grid_columns" name="grid_columns" value="12">
                                <div id="grid_columns_note" class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                    For embossing plates: 2 cells are reserved for row indicators (start/end markers), leaving 12 cells available for text.
                                </div>
                            </div>
                            <div>
                                <label for="grid_rows">Number of Braille Lines:</label>
                                <input type="number" id="grid_rows" name="grid_rows" value="4">
                            </div>
                            <div>
                                <label for="cell_spacing">Braille Cell Spacing:</label>
                                <input type="number" id="cell_spacing" name="cell_spacing" value="6.5" step="0.1">
                            </div>
                            <div>
                                <label for="line_spacing">Braille Line Spacing:</label>
                                <input type="number" id="line_spacing" name="line_spacing" value="10.0" step="0.1">
                            </div>
                            <div>
                                <label for="dot_spacing">Braille Dot Spacing:</label>
                                <input type="number" id="dot_spacing" name="dot_spacing" value="2.5" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Dot Dimensions</label>
                            <div>
                                <label for="emboss_dot_base_diameter">Dot diameter:</label>
                                <input type="number" id="emboss_dot_base_diameter" name="emboss_dot_base_diameter" value="1.8" step="0.1">
                            </div>
                            <div>
                                <label for="emboss_dot_height">Dot height:</label>
                                <input type="number" id="emboss_dot_height" name="emboss_dot_height" value="1.0" step="0.1">
                            </div>
                            <div>
                                <label for="emboss_dot_flat_hat">Flat hat diameter:</label>
                                <input type="number" id="emboss_dot_flat_hat" name="emboss_dot_flat_hat" value="0.4" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Dot Dimensions</label>
                            <div>
                                <label for="counter_plate_dot_size_offset">Counter Dot Diameter Offset (mm):</label>
                                <input type="number" id="counter_plate_dot_size_offset" name="counter_plate_dot_size_offset" value="0.0" step="0.1" aria-describedby="offset-help" title="Adjusts the counter plate braille dot base diameter relative to the emboss plate diameter">
                                <div id="offset-help" class="offset-note" style="font-size: 0.85em; margin-top: 2px;">
                                    Adds or subtracts from the Universal Counter Plate's recessed dot diameter. The dot size mirrors the Embossing Plate's Dot Base Diameter by default.
                                </div>
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Plate Dimensions</label>
                            <div>
                                <label for="card_width">Plate Width:</label>
                                <input type="number" id="card_width" name="card_width" value="90" step="0.1">
                            </div>
                            <div>
                                <label for="card_height">Plate Height:</label>
                                <input type="number" id="card_height" name="card_height" value="52" step="0.1">
                            </div>
                            <div>
                                <label for="card_thickness">Plate Thickness:</label>
                                <input type="number" id="card_thickness" name="card_thickness" value="2.0" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Cylinder Dimensions</label>
                            <div>
                                <label for="cylinder_diameter_mm">Cylinder Diameter (mm):</label>
                                <input type="number" id="cylinder_diameter_mm" name="cylinder_diameter_mm" value="31.35" step="0.1" min="10" max="200">
                            </div>
                            <div>
                                <label for="cylinder_height_mm">Cylinder Height (mm):</label>
                                <input type="number" id="cylinder_height_mm" name="cylinder_height_mm" value="52" step="0.1" min="10" max="200">
                            </div>
                            <div>
                                <label for="cylinder_polygonal_cutout_radius_mm">Polygonal Cutout Inscribed Radius (mm):</label>
                                <input type="number" id="cylinder_polygonal_cutout_radius_mm" name="cylinder_polygonal_cutout_radius_mm" value="13" step="0.1" min="0" max="50">
                                <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                    Creates a 12-point polygonal cutout along the cylinder's length. Set to 0 for no cutout.
                                </div>
                            </div>
                            <div>
                                <label for="seam_offset_deg">Seam Offset (degrees):</label>
                                <input type="number" id="seam_offset_deg" name="seam_offset_deg" value="355" step="1" min="0" max="360">
                                <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                    Rotates the starting position of braille text around the cylinder
                                </div>
                            </div>
                            <div id="cylinder-overflow-warning" class="grade-note" style="margin-top: 10px; color: #d73502; display: none;">
                                <strong>Warning:</strong> <span id="cylinder-overflow-message"></span>
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille / Card Positioning</label>
                            <div>
                                <label for="braille_y_adjust">Y Adjust:</label>
                                <input type="number" id="braille_y_adjust" name="braille_y_adjust" value="0.0" step="0.1">
                            </div>
                            <div>
                                <label for="braille_x_adjust">X Adjust:</label>
                                <input type="number" id="braille_x_adjust" name="braille_x_adjust" value="0.0" step="0.1">
                            </div>
                        </div>
                        
                        <div style="margin-top: 1.5em; text-align: center;">
                            <button type="button" id="preview-braille-btn">Preview Braille Translation</button>
                        </div>
                    </div>

                    <div class="button-group">
                        <!-- Test buttons removed as they are no longer needed -->
                    </div>
                </form>
                
                <div id="braille-preview" class="braille-preview" style="display: none;" role="region" aria-label="Braille translation preview">
                    <h3 class="preview-heading">Braille Translation Preview:</h3>
                    <div id="preview-content"></div>
                </div>
            </div>
        </div>
    </div>
    

    
    <!-- Load the real liblouis JavaScript implementation from static files -->
    <script src="static/liblouis/build-no-tables-utf16.js"></script>
    <script src="static/liblouis/easy-api.js"></script>
    <!-- Runtime config for GitHub Pages / external backend -->
    <script src="static/app-config.js"></script>
    
    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from './static/STLLoader.js';
        import { OrbitControls } from './static/OrbitControls.js';
        import { buildCardEmbossingPlate, buildCylinderEmbossingPlate, buildCardCounterPlate, buildCylinderCounterPlate } from './static/geometry.js';
        import { exportObjectToAsciiSTL } from './static/export-stl.js';
        // Static GH Pages deployment: disable backend completely
        const API_BASE = '';
        const backendAvailable = false;
        async function loadLanguageOptions() {
            const select = document.getElementById('language-table');
            if (!select) return;

            // Preserve the first two default English UEB options
            const defaultValues = new Set(['en-ueb-g2.ctb', 'en-ueb-g1.ctb']);
            const defaultOptions = Array.from(select.querySelectorAll('option')).filter(o => defaultValues.has(o.value));

            // Clear existing and re-add defaults in an optgroup
            select.innerHTML = '';
            const defaultGroup = document.createElement('optgroup');
            defaultGroup.label = 'Default';
            defaultOptions.forEach(o => defaultGroup.appendChild(o));
            select.appendChild(defaultGroup);

            // Load static manifest only (with robust path fallbacks for GitHub Pages)
            let staticData = null;
            const candidateUrls = [
                new URL('./static/tables-manifest.json', import.meta.url).href,
                new URL('../static/tables-manifest.json', import.meta.url).href,
                `${location.origin}/braille-card-and-cylinder-stl-generator-githubpages/static/tables-manifest.json`,
                `${location.origin}/static/tables-manifest.json`
            ];
            for (const href of candidateUrls) {
                try {
                    const resp = await fetch(href, { cache: 'no-store' });
                    if (resp.ok) { staticData = await resp.json(); break; }
                } catch (_e) {}
            }
            // Use static entries only
            const merged = { tables: [] };
            const seenFiles = new Set(defaultValues);
            const pushUnique = (t) => {
                if (!t || !t.file || seenFiles.has(t.file)) return;
                merged.tables.push(t);
                seenFiles.add(t.file);
            };
            if (staticData && Array.isArray(staticData.tables)) {
                staticData.tables.forEach(pushUnique);
            }

            if (!merged.tables || merged.tables.length === 0) return;

            // Build label for each entry (native-language autonyms)
            const otherGroup = document.createElement('optgroup');
            otherGroup.label = 'Other';

            const seen = new Set(defaultValues);
            const entries = merged.tables.slice();

            // Sort: English first, then by locale and file name
            entries.sort((a, b) => {
                const aEn = (a.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                const bEn = (b.locale || '').toLowerCase().startsWith('en') ? 0 : 1;
                if (aEn !== bEn) return aEn - bEn;
                const al = (a.locale || '').toLowerCase();
                const bl = (b.locale || '').toLowerCase();
                if (al !== bl) return al < bl ? -1 : 1;
                const af = (a.file || '').toLowerCase();
                const bf = (b.file || '').toLowerCase();
                return af < bf ? -1 : af > bf ? 1 : 0;
            });

            // Language name mappings with native scripts (autonyms)
            const languageNames = {
                'af': 'Afrikaans',
                'ar': 'العربية', // Arabic
                'as': 'অসমীয়া', // Assamese  
                'aw': 'अवधी', // Awadhi
                'be': 'বাংলা', // Bengali
                'bg': 'Български', // Bulgarian
                'bh': 'भोजपुरी', // Bhojpuri
                'bn': 'বাংলা', // Bengali
                'bo': 'བོད་སྐད་', // Tibetan
                'br': 'ब्राज', // Braj
                'ca': 'Català', // Catalan
                'chr': 'ᏣᎳᎩ', // Cherokee
                'ckb': 'کوردی', // Central Kurdish
                'cs': 'Čeština', // Czech
                'cy': 'Cymraeg', // Welsh
                'da': 'Dansk', // Danish
                'de': 'Deutsch', // German
                'dra': 'द्राविड़', // Dravidian
                'el': 'Ελληνικά', // Greek
                'en': 'English',
                'eo': 'Esperanto',
                'es': 'Español', // Spanish
                'et': 'Eesti', // Estonian
                'fa': 'فارسی', // Persian/Farsi
                'fi': 'Suomi', // Finnish
                'fr': 'Français', // French
                'ga': 'Gaeilge', // Irish
                'gd': 'Gàidhlig', // Scottish Gaelic
                'gez': 'ግዕዝ', // Ge'ez
                'gon': 'गोंडी', // Gondi
                'gu': 'ગુજરાતી', // Gujarati
                'haw': 'ʻŌlelo Hawaiʻi', // Hawaiian
                'he': 'עברית', // Hebrew
                'hi': 'हिन्दी', // Hindi
                'hr': 'Hrvatski', // Croatian
                'hu': 'Magyar', // Hungarian
                'hy': 'Հայերեն', // Armenian
                'is': 'Íslenska', // Icelandic
                'it': 'Italiano', // Italian
                'iu': 'ᐃᓄᒃᑎᑐᑦ', // Inuktitut
                'ka': 'ಕನ್ನಡ', // Kannada
                'kh': 'ខ្មែរ', // Khmer
                'kn': 'ಕನ್ನಡ', // Kannada
                'ko': '한국어', // Korean
                'kok': 'कोंकणी', // Konkani
                'kru': 'कुरुख', // Kurukh
                'ks': 'कॉशुर', // Kashmiri
                'lt': 'Lietuvių', // Lithuanian
                'lv': 'Latviešu', // Latvian
                'mao': 'Te Reo Māori', // Maori
                'ml': 'മലയാളം', // Malayalam
                'mn': 'Монгол', // Mongolian
                'mni': 'মৈতৈলোন্', // Manipuri
                'mr': 'मराठी', // Marathi
                'mt': 'Malti', // Maltese
                'mun': 'मुंडारी', // Mundari
                'mwr': 'मारवाड़ी', // Marwari
                'ne': 'नेपाली', // Nepali
                'nl': 'Nederlands', // Dutch
                'no': 'Norsk', // Norwegian
                'np': 'नेपाली', // Nepali
                'or': 'ଓଡ଼ିଆ', // Odia
                'pa': 'ਪੰਜਾਬੀ', // Punjabi
                'pi': 'पालि', // Pali
                'pl': 'Polski', // Polish
                'pt': 'Português', // Portuguese
                'pu': 'ਪੰਜਾਬੀ', // Punjabi
                'ro': 'Română', // Romanian
                'ru': 'Русский', // Russian
                'sa': 'संस्कृतम्', // Sanskrit
                'sd': 'سنڌي', // Sindhi
                'se': 'Sámegiella', // Northern Sami
                'si': 'සිංහල', // Sinhala
                'sk': 'Slovenčina', // Slovak
                'sl': 'Slovenščina', // Slovenian
                'sot': 'Sesotho', // Southern Sotho
                'sr': 'Српски', // Serbian
                'sv': 'Svenska', // Swedish
                'ta': 'தமிழ்', // Tamil
                'te': 'తెలుగు', // Telugu
                'tr': 'Türkçe', // Turkish
                'tsn': 'Setswana', // Tswana
                'ur': 'اردو', // Urdu
                'vi': 'Tiếng Việt', // Vietnamese
                'zh': '中文', // Chinese
            };

            // Region/country names where needed
            const regionNames = {
                'ZA': 'South Africa',
                'IN': 'India', 
                'US': 'United States',
                'GB': 'United Kingdom',
                'CA': 'Canada',
                'NZ': 'New Zealand',
                'CHN': 'China (Simplified)',
                'TW': 'Taiwan (Traditional)',
                'HK': 'Hong Kong',
                'CH': 'Switzerland',
                'DE': 'Germany',
                'ES': 'Spain',
                'FR': 'France',
                'BE': 'Belgium',
                'NL': 'Netherlands',
                'PT': 'Portugal',
                'AT': 'Austria',
                'MN': 'Mongolia',
                'PK': 'Pakistan',
                'IR': 'Iran',
            };

            // Helper to get language name
            const getLanguageName = (locale) => {
                if (!locale) return '';
                const parts = locale.split('-');
                const lang = parts[0].toLowerCase();
                return languageNames[lang] || lang.charAt(0).toUpperCase() + lang.slice(1);
            };

            // Helper to get full display name
            const getDisplayName = (t) => {
                const locale = (t.locale || '').replace('_', '-');
                const parts = locale.split('-');
                const langCode = parts[0].toLowerCase();
                const region = parts[1] ? parts[1].toUpperCase() : '';
                
                let displayName = getLanguageName(locale);
                
                // Add region if present and meaningful
                if (region && regionNames[region]) {
                    displayName += `, ${regionNames[region]}`;
                } else if (region && region.length === 2) {
                    displayName += ` (${region})`;
                }
                
                return displayName;
            };

            // Process entries
            const usedLabels = new Map(); // Track label -> count

            for (const t of entries) {
                const file = t.file;
                if (!file || seen.has(file)) continue;
                seen.add(file);

                // Get base language name
                let baseName = getDisplayName(t);
                
                // Build description parts
                const parts = [];
                
                // Grade/contraction info
                if (t.grade === '2') {
                    parts.push('contracted');
                } else if (t.grade === '1') {
                    parts.push('uncontracted');
                } else if (t.grade === '0') {
                    parts.push('computer');
                }
                
                // Type info
                if (t.type === 'computer' && !parts.includes('computer')) {
                    if (t.dots === 8) {
                        parts.push('8-dot computer');
                    } else {
                        parts.push('computer');
                    }
                } else if (t.type === 'literary' && t.contraction === 'full') {
                    if (!parts.includes('contracted')) {
                        parts.push('literary');
                    }
                }
                
                // Variant info (UEB, EBAE, etc)
                if (t.variant) {
                    parts.push(t.variant);
                }
                
                // Special naming for specific files
                if (file === 'en-ueb-g2.ctb') {
                    baseName = 'English, U.S.';
                    parts.length = 0;
                    parts.push('contracted', 'UEB grade 2');
                } else if (file === 'en-ueb-g1.ctb') {
                    baseName = 'English, U.S.';
                    parts.length = 0;
                    parts.push('uncontracted', 'UEB grade 1');
                } else if (file.includes('-comp')) {
                    if (!parts.includes('computer') && !parts.includes('8-dot computer')) {
                        parts.push('computer braille');
                    }
                }
                
                // Build final label
                let label = baseName;
                if (parts.length > 0) {
                    label += ` (${parts.join(', ')})`;
                }
                
                // Handle duplicates
                const labelCount = usedLabels.get(label) || 0;
                if (labelCount > 0) {
                    label += ` [${file}]`;
                }
                usedLabels.set(label, labelCount + 1);

                const opt = document.createElement('option');
                opt.value = file;
                opt.textContent = label;
                otherGroup.appendChild(opt);
            }

            select.appendChild(otherGroup);
        }

        // Kick off language options load ASAP
        loadLanguageOptions();

        // Declare 3D scene variables at module scope
        let renderer, scene, camera, mesh, controls;
        let lastSTLUrl = null;
        
        // Production logging - only log errors in production
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const log = {
            debug: isProduction ? () => {} : console.log,
            info: isProduction ? () => {} : console.log,
            warn: isProduction ? () => {} : console.warn,
            error: console.error // Always log errors
        };

        // Theme switching functionality
        const themes = ['dark', 'high-contrast', 'light'];
        const themeIcons = {
            'dark': '🌙',
            'high-contrast': '⚡',
            'light': '🌞'
        };
        const themeNames = {
            'dark': 'Dark',
            'high-contrast': 'High Contrast',
            'light': 'Light'
        };
        
        let currentThemeIndex = 0;
        const savedTheme = localStorage.getItem('preferred-theme');
        if (savedTheme && themes.includes(savedTheme)) {
            currentThemeIndex = themes.indexOf(savedTheme);
            applyTheme(savedTheme);
        } else {
            // Default to dark mode if no saved preference
            applyTheme('dark');
        }

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            // Find the next theme in the cycle
            const currentIndex = themes.indexOf(theme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const nextTheme = themes[nextIndex];
            
            // Show the next theme that will be applied when clicked
            themeIcon.textContent = themeIcons[nextTheme];
            themeText.textContent = themeNames[nextTheme];
            
            // Update aria-label to show current theme and what will happen next
            themeToggle.setAttribute('aria-label', `Current theme: ${themeNames[theme]}. Click to switch to ${themeNames[nextTheme]} theme`);
            
            // Save preference
            localStorage.setItem('preferred-theme', theme);
            
            // Announce theme change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Theme changed to ${themeNames[theme]}`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
            
            // Update 3D scene colors for new theme
            update3DSceneColors();
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(themes[currentThemeIndex]);
        });

        // Function to update 3D scene colors when theme changes
        function update3DSceneColors() {
            if (scene && renderer && camera) {
                const styles = getComputedStyle(document.documentElement);
                const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
                const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
                const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
                const stlMeshColor = styles.getPropertyValue('--stl-mesh-color').trim() || '#6699cc';
                const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
                const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
                
                // Update scene background
                scene.background = new THREE.Color(stlBackground);
                
                // Remove existing lights to rebuild them with proper configuration
                const sceneLightsToRemove = scene.children.filter(child => 
                    child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight
                );
                sceneLightsToRemove.forEach(light => scene.remove(light));
                
                // Also remove camera-attached directional lights
                const cameraLightsToRemove = camera.children.filter(child => 
                    child instanceof THREE.DirectionalLight
                );
                cameraLightsToRemove.forEach(light => camera.remove(light));
                
                // Rebuild lighting based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
                
                if (currentTheme === 'high-contrast') {
                    // High contrast mode: conventional three-point lighting for better detail visibility
                    // Key light: 45° horizontal, 30° vertical (right side) - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);
                    
                    // Fill light: 45° horizontal, 15° vertical (left side) for shadow softening - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                    fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                    
                    // Subtle back light for edge definition - camera-relative
                    const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                    backLight.position.set(0, 0.5, -0.866).normalize();
                    camera.add(backLight);
                } else {
                    // Standard lighting: conventional angle for optimal detail visibility
                    // Key light: 45° horizontal, 30° vertical - camera-relative
                    directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                    camera.add(directionalLight);
                    
                    // Add subtle fill light for standard modes too - camera-relative
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                    fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                    camera.add(fillLight);
                }
                
                // Add ambient light
                scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
                
                // Update mesh color and material properties if mesh exists
                if (mesh && mesh.material) {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    mesh.material.color = new THREE.Color(stlMeshColor);
                    
                    // Update specular properties for high contrast mode
                    if (currentTheme === 'high-contrast') {
                        mesh.material.specular = new THREE.Color(0xffffff); // White specular highlights
                        mesh.material.shininess = 300; // Higher shininess for sharper highlights
                    } else {
                        mesh.material.specular = new THREE.Color(0x111111); // Standard specular
                        mesh.material.shininess = 200; // Standard shininess
                    }
                    
                    mesh.material.needsUpdate = true;
                }
                
                // Force a re-render
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Theme initialization is handled above in the main theme logic

        // Font size adjustment functionality
        const fontSizes = [75, 87.5, 100, 112.5, 125, 150, 175, 200];
        let currentFontSizeIndex = 2; // Start at 100%
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Load saved font size preference
        const savedFontSize = localStorage.getItem('preferred-font-size');
        if (savedFontSize && !isMobile) {
            // Only use saved preference on desktop
            currentFontSizeIndex = fontSizes.indexOf(parseInt(savedFontSize));
            if (currentFontSizeIndex === -1) currentFontSizeIndex = 2;
        } else if (isMobile) {
            // Mobile defaults to 100% unless user has specifically set mobile preference
            const savedMobileFontSize = localStorage.getItem('preferred-mobile-font-size');
            if (savedMobileFontSize) {
                currentFontSizeIndex = fontSizes.indexOf(parseInt(savedMobileFontSize));
                if (currentFontSizeIndex === -1) currentFontSizeIndex = 2; // Default to 100% on mobile
            } else {
                currentFontSizeIndex = 2; // Default to 100% on mobile
            }
        }
        
        function applyFontSize(sizeIndex) {
            const size = fontSizes[sizeIndex];
            document.documentElement.style.fontSize = size + '%';
            document.getElementById('current-font-size').textContent = size;
            currentFontSizeIndex = sizeIndex;
            
            // Save preference with device-specific key
            if (window.innerWidth <= 768) {
                localStorage.setItem('preferred-mobile-font-size', size);
            } else {
                localStorage.setItem('preferred-font-size', size);
            }
            
            // Announce font size change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Font size changed to ${size}%`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }
        
        // Initialize font size
        applyFontSize(currentFontSizeIndex);
        
        // Font size control event listeners
        document.getElementById('font-decrease').addEventListener('click', () => {
            if (currentFontSizeIndex > 0) {
                applyFontSize(currentFontSizeIndex - 1);
            }
        });
        
        document.getElementById('font-increase').addEventListener('click', () => {
            if (currentFontSizeIndex < fontSizes.length - 1) {
                applyFontSize(currentFontSizeIndex + 1);
            }
        });
        
        document.getElementById('font-reset').addEventListener('click', () => {
            applyFontSize(2); // Reset to 100%
        });

        const form = document.getElementById('braille-form');
        const viewer = document.getElementById('viewer');
        const actionBtn = document.getElementById('action-btn');
        let lastGeneratedSTLUrl = null;
        let lastGeneratedFilename = null;

        const previewBrailleBtn = document.getElementById('preview-braille-btn');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        
        // Function to reset button to generate state
        function resetToGenerateState() {
            actionBtn.textContent = 'Generate STL';
            actionBtn.className = 'generate-state';
            actionBtn.setAttribute('data-state', 'generate');
            actionBtn.setAttribute('aria-label', 'Generate STL file from entered text');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Function to set button to download state
        function setToDownloadState() {
            actionBtn.textContent = 'Download STL';
            actionBtn.className = 'download-state';
            actionBtn.setAttribute('data-state', 'download');
            actionBtn.setAttribute('aria-label', 'Download generated STL file');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Store the current plate type for download naming
        let currentPlateType = 'positive';
        
        // Add event handler for the action button
        actionBtn.addEventListener('click', () => {
            if (actionBtn.getAttribute('data-state') === 'generate') {
                form.dispatchEvent(new Event('submit'));
            } else if (actionBtn.getAttribute('data-state') === 'download') {
                // Download the generated STL
                if (lastGeneratedSTLUrl) {
                    const a = document.createElement('a');
                    a.href = lastGeneratedSTLUrl;
                    // Use the filename generated on the frontend
                    if (lastGeneratedFilename) {
                        a.download = lastGeneratedFilename;
                    }
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
        });
        const expertToggleBtn = document.getElementById('expert-toggle');
        const expertSettings = document.getElementById('expert-settings');
        const expertToggleText = document.getElementById('expert-toggle-text');
        const expertToggleIcon = document.getElementById('expert-toggle-icon');
        const braillePreview = document.getElementById('braille-preview');
        const previewContent = document.getElementById('preview-content');
        const infoToggleBtn = document.getElementById('info-toggle');
        const infoContent = document.getElementById('info-content');
        const infoToggleText = document.getElementById('info-toggle-text');
        const infoToggleIcon = document.getElementById('info-toggle-icon');



        // Add event listeners to reset button state when inputs change
        function addInputChangeListeners() {
            // Dynamic text input fields
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                if (input) {
                    // Remove existing listener to prevent duplicates
                    input.removeEventListener('input', resetToGenerateState);
                    input.addEventListener('input', resetToGenerateState);
                }
            }
            
            // Language selection
            const languageSelect = document.getElementById('language-table');
            if (languageSelect) {
                languageSelect.addEventListener('change', resetToGenerateState);
            }
            
            // Function to update grid columns based on plate type
            function updateGridColumnsForPlateType(preserveValue = false) {
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const gridColumnsInput = document.getElementById('grid_columns');
                const gridColumnsLabel = document.getElementById('grid_columns_label');
                const gridColumnsNote = document.getElementById('grid_columns_note');
                
                // Store current value before update
                const currentValue = parseInt(gridColumnsInput.value);
                
                if (plateType === 'positive') {
                    // Embossing plate - show available cells (total - 2)
                    gridColumnsLabel.textContent = 'Number of Available Braille Cells:';
                    gridColumnsNote.style.display = 'block';
                    gridColumnsNote.textContent = 'For embossing plates: 2 cells are reserved for row indicators (start/end markers).';
                    
                    if (!preserveValue) {
                        // Only set default value if not preserving user's custom value
                        // Show user the available cells (12), backend will add 2 for indicators
                        gridColumnsInput.value = '12';
                    } else {
                        // Convert from backend value (total) to displayed value (available)
                        if (currentValue > 2) {
                            gridColumnsInput.value = String(currentValue - 2);
                        }
                    }
                } else {
                    // Counter plate - show available cells (total - 2)
                    gridColumnsLabel.textContent = 'Available Braille Cells for Text:';
                    gridColumnsNote.textContent = 'For counter plates: 2 cells are reserved for row indicators (start/end markers), leaving 12 cells available for text.';
                    gridColumnsNote.style.display = 'block';
                    
                    if (!preserveValue) {
                        // Only set default value if not preserving user's custom value
                        // Show user the available cells (12), backend will add 2 for indicators
                        gridColumnsInput.value = '12';
                    } else {
                        // Convert from backend value (total) to displayed value (available)
                        if (currentValue > 2) {
                            gridColumnsInput.value = String(currentValue - 2);
                        }
                    }
                }
            }
            
            // Plate type radio buttons
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateGridColumnsForPlateType();
                });
            });
            
            // Initialize grid columns on page load
            updateGridColumnsForPlateType();
            
            // Shape type radio buttons
            document.querySelectorAll('input[name="shape_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                    // Save shape selection to localStorage
                    try {
                        localStorage.setItem('brailleGeneratorShapeType', this.value);
                        log.debug('Saved shape type to localStorage:', this.value);
                    } catch (e) {
                        // Silently fail if localStorage is not available
                        log.warn('Could not save shape type to localStorage:', e);
                    }
                });
            });
            
            // Counter plate offset
            const counterPlateOffset = document.getElementById('counter_plate_dot_size_offset');
            if (counterPlateOffset) {
                counterPlateOffset.addEventListener('input', resetToGenerateState);
            }
            
            // Expert mode parametric dials
            const expertInputs = [
                'emboss_dot_base_diameter',
                'emboss_dot_height', 
                'emboss_dot_flat_hat',
                'counter_plate_dot_size_offset',
                'grid_columns',
                'grid_rows',
                'cell_spacing',
                'line_spacing',
                'dot_spacing',
                'card_width',
                'card_height',
                'card_thickness',
                'braille_x_adjust',
                'braille_y_adjust'
            ];
            
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', resetToGenerateState);
                }
            });
            
            // Cylinder parameter inputs
            const cylinderInputs = [
                'cylinder_diameter_mm',
                'cylinder_height_mm',
                'cylinder_polygonal_cutout_radius_mm',
                'seam_offset_deg'
            ];
            
            cylinderInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        checkCylinderOverflow();
                    });
                }
            });
        }
        
        // Function to show/hide cylinder settings based on shape selection
        function updateShapeSettings() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement) {
                console.warn('No shape type selected');
                return;
            }
            const shapeType = shapeTypeElement.value;
            // Avoid :has() selector for broader browser support
            const cylinderSettings = (function() {
                const sections = document.querySelectorAll('.grade-selection');
                for (const section of sections) {
                    if (section.querySelector('#cylinder_diameter_mm')) return section;
                }
                return null;
            })();
            
            // Always show cylinder dimensions in expert mode
            if (cylinderSettings) {
                cylinderSettings.style.display = 'block';
            }
            
            // Initialize cylinder height with current card height when cylinder is selected
            if (shapeType === 'cylinder') {
                const cardHeight = document.getElementById('card_height').value;
                const cylinderHeightInput = document.getElementById('cylinder_height_mm');
                if (cylinderHeightInput) {
                    cylinderHeightInput.value = cardHeight;
                }
                checkCylinderOverflow();
            }
        }
        
        // Function to check cylinder text overflow
        function checkCylinderOverflow() {
            const shapeTypeElement = document.querySelector('input[name="shape_type"]:checked');
            if (!shapeTypeElement || shapeTypeElement.value !== 'cylinder') return;
            const shapeType = shapeTypeElement.value;
            
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 31.35;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const dotSpacing = parseFloat(document.getElementById('dot_spacing').value) || 2.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            
            // Calculate how many cells fit around circumference
            // cellSpacing is the center-to-center distance between cells
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            
            // Calculate how many rows fit on cylinder
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            
            // Get total cells needed from text
            const lines = getDynamicLineValues();
            let totalCellsNeeded = 0;
            lines.forEach(line => {
                if (line.trim()) {
                    totalCellsNeeded += line.trim().length;
                }
            });
            
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            
            const warningDiv = document.getElementById('cylinder-overflow-warning');
            const warningMessage = document.getElementById('cylinder-overflow-message');
            
            if (totalCellsNeeded > totalCellsAvailable) {
                warningMessage.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }

        // Function to create dynamic line inputs based on grid_rows value
        function createDynamicLineInputs(numLines) {
            const container = document.getElementById('dynamic-line-inputs');
            container.innerHTML = ''; // Clear existing inputs
            
            for (let i = 1; i <= numLines; i++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'line-input';
                lineDiv.innerHTML = `
                    <label for="line${i}" class="line-label">Line ${i}</label>
                    <input type="text" id="line${i}" name="line${i}" placeholder="Enter English text here..." maxlength="50" aria-describedby="line${i}-help">
                    <span id="line${i}-help" class="sr-only">Maximum 50 characters for line ${i}</span>
                `;
                container.appendChild(lineDiv);
            }
            
            // Re-add event listeners for the new inputs
            addInputChangeListeners();
        }

        // Function to collect all dynamic line values
        function getDynamicLineValues() {
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            const lines = [];
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                lines.push(input ? input.value : '');
            }
            // Ensure we always return at least 4 lines for backend compatibility
            while (lines.length < 4) {
                lines.push('');
            }
            return lines;
        }

        // Function to add listener for grid_rows changes
        function addGridRowsListener() {
            const gridRowsInput = document.getElementById('grid_rows');
            if (gridRowsInput) {
                gridRowsInput.addEventListener('input', () => {
                    const numLines = parseInt(gridRowsInput.value) || 4;
                    // Clamp to reasonable limits
                    const clampedLines = Math.max(1, Math.min(10, numLines));
                    if (clampedLines !== numLines) {
                        gridRowsInput.value = clampedLines;
                    }
                    createDynamicLineInputs(clampedLines);
                    resetToGenerateState();
                });
            }
        }
        
        // Initialize dynamic line inputs and listeners
        createDynamicLineInputs(4); // Start with default 4 lines
        addInputChangeListeners();
        addGridRowsListener();
        
        // Initialize shape settings to show/hide cylinder parameters correctly
        updateShapeSettings();

        expertToggleBtn.addEventListener('click', () => {
            const isVisible = expertSettings.style.display !== 'none';
            expertSettings.style.display = isVisible ? 'none' : 'block';
            expertToggleText.textContent = isVisible ? 'Show Expert Mode' : 'Hide Expert Mode';
            expertToggleIcon.textContent = isVisible ? '▼' : '▲';
            expertToggleBtn.classList.toggle('active', !isVisible);
        });

        infoToggleBtn.addEventListener('click', () => {
            const isVisible = infoContent.style.display !== 'none';
            infoContent.style.display = isVisible ? 'none' : 'block';
                                        infoToggleText.textContent = isVisible ? 'More Info' : 'Hide Information';
            infoToggleIcon.textContent = isVisible ? '▼' : '▲';
            infoToggleBtn.classList.toggle('active', !isVisible);
        });

        // Add real-time debugging for Expert Mode parametric dials
        const expertInputs = [
            'emboss_dot_base_diameter',
            'emboss_dot_height', 
            'emboss_dot_flat_hat',
            'grid_columns',
            'grid_rows',
            'cell_spacing',
            'line_spacing',
            'dot_spacing',
            'card_width',
            'card_height',
            'card_thickness',
            'braille_x_adjust',
            'braille_y_adjust',
            'cylinder_diameter_mm',
            'cylinder_height_mm',
            'cylinder_polygonal_cutout_radius_mm',
            'seam_offset_deg'
        ];
        
        expertInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', (e) => {
                    log.debug(`Expert Mode Input Changed: ${inputId} = ${e.target.value}`);
                    
                    // If grid_columns changed, update the label/note but preserve the value
                    if (inputId === 'grid_columns') {
                        updateGridColumnsForPlateType(true);
                    }
                });
                
                // Also log the initial values
                log.debug(`Initial value for ${inputId}: ${input.value}`);
            }
        });
        
        // Function to get current Expert Mode values
        window.getCurrentExpertModeValues = function() {
            const values = {};
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    values[inputId] = input.value;
                }
            });
            return values;
        };

        // Preview braille translation using real liblouis
        previewBrailleBtn.addEventListener('click', async () => {
            // Reset button state when previewing (user is making changes)
            resetToGenerateState();
            const lines = getDynamicLineValues();
            
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;
            
            if (lines.every(line => !line.trim())) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }

            errorDiv.style.display = 'none';
            let previewHTML = '';
            
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim()) {
                    try {
                        // Use real liblouis translation with selected table
                        const braille = await translateWithLiblouis(lines[i].trim(), 'g2', tableName);
                        previewHTML += `<div class="preview-line-success">
                            <strong>Line ${i + 1}:</strong> "${lines[i].trim()}" → "${braille}"
                        </div>`;
                    } catch (error) {
                        log.error('Translation failed for line', i + 1, ':', error);
                        previewHTML += `<div class="preview-line-error">
                            <strong>Line ${i + 1}:</strong> "${lines[i].trim()}" → Error: ${error.message}
                        </div>`;
                    }
                }
            }
            
            previewContent.innerHTML = previewHTML;
            braillePreview.style.display = 'block';
        });

        function init3D() {
            // Mobile-optimized renderer settings
            const isMobile = window.innerWidth <= 768;
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile, // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
            viewer.innerHTML = '';
            viewer.appendChild(renderer.domElement);
            
            // Get theme-appropriate colors with proper fallbacks
            const styles = getComputedStyle(document.documentElement);
            const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
            const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
            const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
            const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(stlBackground);
            
            camera = new THREE.PerspectiveCamera(45, viewer.clientWidth/viewer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 120);
            camera.up.set(0, 1, 0); // Default Y-up
            camera.lookAt(0, 0, 0);
            
            // Add camera to scene so attached lights will work
            scene.add(camera);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            
            // Mobile-optimized controls
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.5 : 1.0;
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.panSpeed = isMobile ? 0.5 : 0.8;
            
            // Touch-specific settings
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            controls.update();
            
            // Theme-appropriate lighting with intensity control
            const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
            
            // Position the directional light for optimal detail visibility
            // Use conventional 3D modeling lighting angles
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'high-contrast') {
                // High contrast mode: conventional three-point lighting for better detail visibility
                // Key light: 45° horizontal, 30° vertical (right side) - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);
                
                // Fill light: 45° horizontal, 15° vertical (left side) for shadow softening - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.4);
                fillLight.position.set(-0.707, 0.259, 0.659).normalize();
                camera.add(fillLight);
                
                // Subtle back light for edge definition - camera-relative
                const backLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.2);
                backLight.position.set(0, 0.5, -0.866).normalize();
                camera.add(backLight);
            } else {
                // Standard lighting: conventional angle for optimal detail visibility
                // Key light: 45° horizontal, 30° vertical - camera-relative
                directionalLight.position.set(0.707, 0.5, 0.612).normalize();
                camera.add(directionalLight);
                
                // Add subtle fill light for standard modes too - camera-relative
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                fillLight.position.set(-0.5, 0.259, 0.659).normalize();
                camera.add(fillLight);
            }
            
            scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
            
            // Handle window resize for mobile orientation changes
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            camera.aspect = viewer.clientWidth / viewer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        form.onsubmit = async (e) => {
            e.preventDefault();
            errorDiv.style.display = 'none';
            errorText.textContent = '';
            
            // Collect all dynamic line inputs
            const lines = getDynamicLineValues();
            
            const plateType = document.querySelector('input[name="plate_type"]:checked').value;
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;
            
            // Translate text to braille only for positive plates
            let translatedLines = [];
            let translationErrors = [];
            if (plateType === 'positive') {
                // Translate text to braille before sending to backend
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        try {
                            log.debug(`Translating line ${i + 1}: '${line}' to braille using table: ${tableName}...`);
                            const brailleText = await translateWithLiblouis(line, 'g2', tableName);
                            log.debug(`Line ${i + 1} translated: '${line}' → '${brailleText}'`);
                            translatedLines.push(brailleText);
                        } catch (error) {
                            log.error(`Failed to translate line ${i + 1}:`, error);
                            // Track translation failure
                            translationErrors.push({
                                line: i + 1,
                                text: line,
                                error: error.toString()
                            });
                            // Push empty string to maintain line alignment
                            translatedLines.push('');
                        }
                    } else {
                        translatedLines.push('');
                    }
                }
                log.debug('Original lines:', lines);
                log.debug('Translated lines:', translatedLines);
                
                // Check if any translation errors occurred
                if (translationErrors.length > 0) {
                    let errorMessage = '<strong>Translation failed for the following lines:</strong><br><br>';
                    translationErrors.forEach(err => {
                        errorMessage += `Line ${err.line}: "${err.text}"<br>`;
                    });
                    errorMessage += '<br><strong>Please check your text and try again.</strong><br><br>';
                    errorMessage += 'Common issues include:<br>';
                    errorMessage += '• Special characters that cannot be translated<br>';
                    errorMessage += '• Text that is incompatible with the selected braille table<br>';
                    errorMessage += '• System errors during translation<br><br>';
                    errorMessage += '<em>The STL file was not generated to prevent producing incorrect braille.</em>';
                    
                    errorText.innerHTML = errorMessage;  // Use innerHTML for HTML formatting
                    errorDiv.style.display = 'flex';
                    errorDiv.className = 'error-message';
                    
                    // Re-enable button and reset to generate state
                    resetToGenerateState();
                    return;
                }
            } else {
                // Counter plates don't need text - just pass empty lines
                translatedLines = ['', '', '', ''];
                log.debug('Counter plate selected - no text translation needed');
            }
            const settings = {
                // For both plate types, add 2 to account for reserved cells (indicators)
                // The frontend displays the available cells, but backend needs total cells
                grid_columns: String(parseInt(document.getElementById('grid_columns').value) + 2),
                grid_rows: document.getElementById('grid_rows').value,
                cell_spacing: document.getElementById('cell_spacing').value,
                line_spacing: document.getElementById('line_spacing').value,
                dot_spacing: document.getElementById('dot_spacing').value,
                emboss_dot_base_diameter: document.getElementById('emboss_dot_base_diameter').value,
                emboss_dot_height: document.getElementById('emboss_dot_height').value,
                emboss_dot_flat_hat: document.getElementById('emboss_dot_flat_hat').value,
                counter_plate_dot_size_offset: document.getElementById('counter_plate_dot_size_offset').value,
                card_width: document.getElementById('card_width').value,
                card_height: document.getElementById('card_height').value,
                card_thickness: document.getElementById('card_thickness').value,
                braille_x_adjust: document.getElementById('braille_x_adjust').value,
                braille_y_adjust: document.getElementById('braille_y_adjust').value
            };
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Settings object keys:', Object.keys(settings));
            log.debug('Settings object values:', Object.values(settings));
            
            // Check if at least one line has content (only for positive plates)
            if (plateType === 'positive' && lines.every(line => !line.trim())) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }
            
            // Validate braille character limits AFTER translation
            const gridColumnsValue = parseInt(document.getElementById('grid_columns').value);
            if (plateType === 'positive') {
                // For embossing plates, we need to account for 2 reserved cells
                // Use the actual grid columns value from the input (not hardcoded)
                const actualGridColumns = gridColumnsValue + 2; // Add back the 2 reserved cells
                const availableColumns = gridColumnsValue; // What the user sees is available cells
                
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > availableColumns) {
                        const over = brailleLine.length - availableColumns;
                        errorText.textContent = `Line ${i + 1} exceeds ${availableColumns} available braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            } else {
                // For counter plates, all grid columns are available
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > gridColumnsValue) {
                        const over = brailleLine.length - gridColumnsValue;
                        errorText.textContent = `Line ${i + 1} exceeds ${gridColumnsValue} braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            }
            
            // Show loading message
            errorText.textContent = plateType === 'positive' ? 'Translating text to braille...' : 'Generating counter plate...';
            errorDiv.style.display = 'flex';
            errorDiv.className = 'error-message info';
            
            // Update button to show loading state
            actionBtn.disabled = true;
            actionBtn.textContent = 'Generating...';
            actionBtn.style.opacity = '0.7';
            
            // Get shape type and cylinder params
            const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
            let cylinderParams = {};
            
            if (shapeType === 'cylinder') {
                cylinderParams = {
                    diameter_mm: document.getElementById('cylinder_diameter_mm').value,
                    height_mm: document.getElementById('cylinder_height_mm').value,
                    polygonal_cutout_radius_mm: document.getElementById('cylinder_polygonal_cutout_radius_mm').value,
                    seam_offset_deg: document.getElementById('seam_offset_deg').value
                };
            }
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Shape Type:', shapeType);
            log.debug('Cylinder Params:', cylinderParams);
            
            try {
                // Client-side STL generation using OpenJSCAD in a module worker; fallback to Three.js on error
                let stlBlob;
                try {
                    const workerUrl = new URL('static/jscad-worker.js', document.baseURI);
                    const jscadWorker = new Worker(workerUrl.href, { type: 'module' });
                    const reqId = Math.random().toString(36).slice(2);
                    const msg = { id: reqId, type: 'generate', data: { plateType, shapeType, settings, cylinderParams, translatedLines } };
                    const stlText = await new Promise((resolve, reject) => {
                        const timer = setTimeout(() => reject(new Error('JSCAD worker timeout')), 20000);
                        jscadWorker.onmessage = (e) => {
                            const { id, type, result } = e.data || {};
                            if (id !== reqId || type !== 'generate') return;
                            clearTimeout(timer);
                            jscadWorker.terminate();
                            if (result && result.success) resolve(result.stlText);
                            else reject(new Error(result && result.error ? result.error : 'Unknown worker error'));
                        };
                        jscadWorker.onerror = (err) => { clearTimeout(timer); jscadWorker.terminate(); reject(err.message || String(err)); };
                        jscadWorker.postMessage(msg);
                    });
                    stlBlob = new Blob([stlText], { type: 'model/stl' });
                } catch (workerErr) {
                    log.error('JSCAD worker failed, falling back to Three.js STL generation:', workerErr);
                    let object3D;
                    if (plateType === 'positive') {
                        if (shapeType === 'cylinder') {
                            object3D = buildCylinderEmbossingPlate(translatedLines, settings, cylinderParams);
                        } else {
                            object3D = buildCardEmbossingPlate(translatedLines, settings);
                        }
                    } else {
                        if (shapeType === 'cylinder') {
                            object3D = buildCylinderCounterPlate(settings, cylinderParams);
                        } else {
                            object3D = buildCardCounterPlate(settings);
                        }
                    }
                    stlBlob = exportObjectToAsciiSTL(object3D, `braille_${plateType}_${shapeType}`);
                }
                if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                lastSTLUrl = URL.createObjectURL(stlBlob);
                
                // Generate filename on frontend to match backend logic
                let filename = plateType === 'positive' ? 'braille_embossing_plate' : 'braille_counter_plate';
                
                if (plateType === 'positive') {
                    // Get the current lines from the form
                    const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const lines = [];
                    for (let i = 1; i <= gridRows; i++) {
                        const input = document.getElementById(`line${i}`);
                        lines.push(input ? input.value : '');
                    }
                    
                    // Find first non-empty line (prioritizing Line 1)
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            // Sanitize filename: remove special characters and limit length
                            let sanitized = lines[i].trim().substring(0, 30);
                            sanitized = sanitized.replace(/[^\w\s-]/g, '');
                            sanitized = sanitized.replace(/[-\s]+/g, '_').replace(/^_+|_+$/g, '');
                            
                            if (sanitized) {
                                filename = `braille_embossing_plate_${sanitized}-${shapeType}`;
                                break;
                            }
                        }
                    }
                    // If no text was found, still append shape type
                    if (!filename.includes(shapeType)) {
                        filename = `braille_embossing_plate-${shapeType}`;
                    }
                } else {
                    // For counter plates, include total diameter (base + offset) in filename
                    const dotDiameter = parseFloat(document.getElementById('emboss_dot_base_diameter').value) || 0;
                    const counterOffset = parseFloat(document.getElementById('counter_plate_dot_size_offset').value) || 0;
                    const totalDiameter = dotDiameter + counterOffset;
                    filename = `braille_counter_plate_${totalDiameter}mm-${shapeType}`;
                }
                
                // Store the generated STL URL and filename for download
                lastGeneratedSTLUrl = lastSTLUrl;
                lastGeneratedFilename = `${filename}.stl`;
                loadSTL(lastSTLUrl);
                
                // Change button to download state after successful generation
                actionBtn.disabled = false;
                setToDownloadState();
            } catch (e) {
                errorText.textContent = 'Failed to process STL file: ' + e.message;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
            }
        };



        function loadSTL(url) {
            init3D();
            const loader = new STLLoader();
            loader.load(url, function (geometry) {
                if (mesh) scene.remove(mesh);
                
                // Center the geometry first
                geometry.center();
                
                // Compute bounding box after centering to detect object type
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const width = bbox.max.x - bbox.min.x;
                const height = bbox.max.y - bbox.min.y; 
                const depth = bbox.max.z - bbox.min.z;
                
                // Check if this is a cylinder
                const shapeType = document.querySelector('input[name="shape_type"]:checked')?.value;
                const isCylinder = shapeType === 'cylinder' || height > Math.max(width, depth) * 1.5;
                
                // Get theme-appropriate mesh color with proper fallback
                const styles = getComputedStyle(document.documentElement);
                const meshColorVar = styles.getPropertyValue('--stl-mesh-color').trim();
                const meshColor = meshColorVar || '#6699cc';
                // Enhanced material for high contrast mode
                const currentTheme = document.documentElement.getAttribute('data-theme');
                let material;
                
                if (currentTheme === 'high-contrast') {
                    // High contrast material with enhanced specular highlights
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0xffffff, // White specular highlights for maximum contrast
                        shininess: 300, // Higher shininess for sharper highlights
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Standard material for other themes
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0x111111, 
                        shininess: 200,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = 0;
                scene.add(mesh);
                
                // Adjust camera position based on object type
                if (isCylinder) {
                    // For cylinders: view from the side
                    // After centering, the cylinder is at origin (0,0,0)
                    // The cylinder's axis is along the Z-direction

                    // Ensure camera up vector is correct for upright viewing BEFORE lookAt
                    camera.up.set(0, 0, 1); // Z-axis is up for the cylinder

                    // Position camera to view cylinder upright from the side
                    // Set camera on the +X axis looking toward origin
                    camera.position.set(120, 0, 0);
                    controls.target.set(0, 0, 0);
                    camera.lookAt(0, 0, 0);

                    // Recreate controls so internal up-vector transform matches camera.up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(0, 0, 0);
                    // Reapply standard control settings
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    // Panning orthogonal to world up for Z-up scenes
                    controls.screenSpacePanning = false;

                    camera.updateProjectionMatrix();
                } else {
                    // For cards: keep default front view with Y-up
                    camera.position.set(0, 0, 120);
                    camera.up.set(0, 1, 0); // Y-axis is up for cards (default)
                    camera.lookAt(0, 0, 0);
                    // Recreate controls to ensure correct up-vector mapping when switching back to Y-up
                    if (controls) controls.dispose();
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.target.set(0, 0, 0);
                    {   const isMobile = window.innerWidth <= 768;
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
                        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
                        controls.panSpeed = isMobile ? 0.5 : 0.8;
                        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
                    }
                    controls.screenSpacePanning = true;
                    camera.updateProjectionMatrix();
                }
                
                // Force controls to update with new camera settings
                controls.update();
                controls.saveState(); // Save the new camera state as default
                
                animate();
            }, undefined, function (error) {
                errorText.textContent = 'Failed to load STL: ' + error;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls && controls.update();
            render();
        }
        
        // Initialize liblouis web worker and 3D viewer on page load
        let liblouisWorker = null;
        let liblouisReady = false;
        let workerMessageId = 0;
        let pendingWorkerMessages = new Map();
        
        // Function to send message to worker and get response
        function sendWorkerMessage(type, data = {}) {
            return new Promise((resolve, reject) => {
                if (!liblouisWorker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }
                
                const id = ++workerMessageId;
                pendingWorkerMessages.set(id, { resolve, reject });
                
                liblouisWorker.postMessage({ id, type, data });
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingWorkerMessages.has(id)) {
                        pendingWorkerMessages.delete(id);
                        reject(new Error('Worker message timeout'));
                    }
                }, 10000);
            });
        }
        
        // Mobile-specific utilities
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
        
        // Handle mobile keyboard visibility and orientation changes
        if (isMobileDevice()) {
            const inputs = document.querySelectorAll('input[type="text"], input[type="number"], select');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll input into view when keyboard appears
                    setTimeout(() => {
                        input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
            
            // Handle orientation changes to maintain 200% zoom
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        applyFontSize(6); // Reset to 200% on orientation change
                    }
                }, 100);
            });
        }
        
        window.addEventListener('load', async () => {
            try {
                // Initialize liblouis web worker
                log.debug('Initializing liblouis web worker...');
                
                // Construct a worker from a Blob to avoid base-path and CORS issues
                const staticBase = new URL('./static/', import.meta.url).href;
                const workerSource = `
                    let liblouisInstance = null; let liblouisReady = false;
                    try {
                        importScripts('${staticBase}liblouis/build-no-tables-utf16.js');
                        importScripts('${staticBase}liblouis/easy-api.js');
                    } catch (e) { self.postMessage({ id: -1, type: 'init', result: { success: false, error: 'Worker imports failed: ' + e.message } }); }
                    async function initializeLiblouis(){
                        try {
                            await new Promise(r=>setTimeout(r,50));
                            if (typeof self.LiblouisEasyApi !== 'undefined') {
                                liblouisInstance = new self.LiblouisEasyApi();
                                try { liblouisInstance.enableOnDemandTableLoading('${staticBase}liblouis/tables/'); } catch (_ignored) {}
                                liblouisReady = true; return { success: true };
                            } else { throw new Error('Liblouis Easy API not loaded'); }
                        } catch (err) { return { success: false, error: err.message }; }
                    }
                    self.onmessage = async (e)=>{
                        const { id, type, data } = e.data;
                        try {
                            if (type === 'init') { const r = await initializeLiblouis(); self.postMessage({ id, type: 'init', result: r }); return; }
                            if (type === 'translate') {
                                if (!liblouisReady || !liblouisInstance) throw new Error('Liblouis not initialized');
                                const { text, grade, tableName } = data || {};
                                const selected = tableName ? tableName : (grade === 'g2' ? 'en-ueb-g2.ctb' : 'en-ueb-g1.ctb');
                                const tableFormat = 'unicode.dis,' + selected;
                                const out = liblouisInstance.translateString(tableFormat, text);
                                const ok = out.split('').some(c=>{ const code=c.charCodeAt(0); return code>=0x2800 && code<=0x28FF; });
                                if (!ok) throw new Error('Translation not Unicode braille');
                                self.postMessage({ id, type: 'translate', result: { success: true, translation: out } });
                                return;
                            }
                            throw new Error('Unknown message type');
                        } catch (err) { self.postMessage({ id, type, result: { success: false, error: err.message } }); }
                    };
                `;
                const blob = new Blob([workerSource], { type: 'application/javascript' });
                const blobUrl = URL.createObjectURL(blob);
                liblouisWorker = new Worker(blobUrl);
                
                // Handle worker messages
                liblouisWorker.onmessage = function(e) {
                    const { id, type, result } = e.data;
                    
                    if (pendingWorkerMessages.has(id)) {
                        const { resolve, reject } = pendingWorkerMessages.get(id);
                        pendingWorkerMessages.delete(id);
                        
                        if (result.success) {
                            resolve(result);
                        } else {
                            reject(new Error(result.error));
                        }
                    }
                };
                
                liblouisWorker.onerror = function(error) {
                    log.error('Worker error:', error);
                };
                
                // Initialize liblouis in the worker
                const initResult = await sendWorkerMessage('init');
                if (initResult.success) {
                    liblouisReady = true;
                    log.debug('Liblouis web worker initialized successfully');
                } else {
                    throw new Error('Failed to initialize liblouis worker: ' + initResult.error);
                }
                
            } catch (error) {
                log.error('Failed to initialize liblouis worker:', error);
                
                // Fallback: disable liblouis and show error message
                log.debug('Web worker failed - disabling liblouis translation');
                liblouisReady = false;
                liblouisWorker = null;
                
                // Show user that translation is disabled
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                if (errorDiv && errorText) {
                    errorText.textContent = 'Web worker failed to initialize. Braille translation preview is disabled on this deployment.';
                    errorDiv.style.display = 'flex';
                }
            }
            
            // Restore saved shape selection from localStorage
            try {
                const savedShapeType = localStorage.getItem('brailleGeneratorShapeType');
                if (savedShapeType) {
                    const shapeRadio = document.querySelector(`input[name="shape_type"][value="${savedShapeType}"]`);
                    if (shapeRadio) {
                        shapeRadio.checked = true;
                        updateShapeSettings();
                        log.debug('Restored shape type from localStorage:', savedShapeType);
                    } else {
                        // Fallback default: Cylinder
                        document.querySelector('input[name="shape_type"][value="cylinder"]').checked = true;
                    }
                } else {
                    // No saved shape, default to Cylinder
                    document.querySelector('input[name="shape_type"][value="cylinder"]').checked = true;
                }
            } catch (e) {
                // If localStorage fails, default to Cylinder
                document.querySelector('input[name="shape_type"][value="cylinder"]').checked = true;
                log.warn('Could not restore shape type from localStorage:', e);
            }
            
            // Static mode, no backend detection
            init3D();
            animate();
        });

        // Function to translate text using liblouis web worker
        async function translateWithLiblouis(text, grade, tableName = null) {
            if (!liblouisReady || !liblouisWorker) {
                throw new Error('Liblouis worker not initialized - translation preview unavailable on this deployment');
            }
            
            try {
                log.debug('Sending translation request to worker:', text, 'grade:', grade, 'table:', tableName);
                const result = await sendWorkerMessage('translate', { text, grade, tableName });
                
                if (result.success && result.translation) {
                    log.debug('Translation successful:', result.translation);
                    return result.translation;
                } else {
                    throw new Error('Translation failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                log.error('Worker translation failed:', error);
                throw error;
            }
        }




    </script>
</body>
</html> 