<!-- VERSION: 2024-12-19-revised -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Braille Business Card STL Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* Theme CSS Variables */
        :root {
            /* Light mode colors */
            --bg-gradient-start: #e0e7ff;
            --bg-gradient-end: #f6f8fa;
            --bg-primary: #fff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-input: #f9fafb;
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-tertiary: #666;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --border-focus: #3182ce;
            --btn-primary-bg: linear-gradient(90deg, #3182ce 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #2563eb 60%, #4299e1 100%);
            --btn-success-bg: #10b981;
            --btn-success-hover-bg: #059669;
            --btn-secondary-bg: #9ca3af;
            --btn-tertiary-bg: #6b7280;
            --error-bg: #fee2e2;
            --error-border: #fecaca;
            --error-text: #b91c1c;
            --info-bg: #dbeafe;
            --info-border: #93c5fd;
            --info-text: #1e40af;
            --shadow-light: rgba(49,130,206,0.10);
            --shadow-medium: rgba(49,130,206,0.18);
            --stl-mesh-color: #6699cc;
            --stl-background: #f1f5f9;
            --stl-ambient-light: #888888;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.5;
            --stl-directional-intensity: 1.0;
        }

        /* Dark mode colors */
        [data-theme="dark"] {
            --bg-gradient-start: #1a202c;
            --bg-gradient-end: #2d3748;
            --bg-primary: #2d3748;
            --bg-secondary: #374151;
            --bg-tertiary: #4a5568;
            --bg-input: #374151;
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-primary: #4a5568;
            --border-secondary: #718096;
            --border-focus: #63b3ed;
            --btn-primary-bg: linear-gradient(90deg, #4299e1 60%, #63b3ed 100%);
            --btn-primary-hover-bg: linear-gradient(90deg, #3182ce 60%, #4299e1 100%);
            --btn-success-bg: #059669;
            --btn-success-hover-bg: #047857;
            --btn-secondary-bg: #718096;
            --btn-tertiary-bg: #4a5568;
            --error-bg: #742a2a;
            --error-border: #9b2c2c;
            --error-text: #fed7d7;
            --info-bg: #2c5282;
            --info-border: #3182ce;
            --info-text: #bee3f8;
            --shadow-light: rgba(0,0,0,0.3);
            --shadow-medium: rgba(0,0,0,0.5);
            --stl-mesh-color: #90cdf4;
            --stl-background: #2d3748;
            --stl-ambient-light: #666666;
            --stl-directional-light: #ffffff;
            --stl-ambient-intensity: 0.6;
            --stl-directional-intensity: 0.9;
        }

        /* High contrast mode */
        [data-theme="high-contrast"] {
            --bg-gradient-start: #000000;
            --bg-gradient-end: #000000;
            --bg-primary: #000000; /* Keep black background */
            --bg-secondary: #1a1a1a; /* Keep dark background */
            --bg-tertiary: #2a2a2a; /* Keep dark background */
            --bg-input: #1a1a1a; /* Keep dark background for inputs */
            --text-primary: #02fe05; /* Green instead of white */
            --text-secondary: #02fe05; /* Green instead of white */
            --text-tertiary: #02fe05; /* Green instead of white */
            --border-primary: #ffff00;
            --border-secondary: #00ffff;
            --border-focus: #ff00ff;
            --btn-primary-bg: #02fe05; /* Green */
            --btn-primary-hover-bg: #02fe05; /* Green */
            --btn-success-bg: #02fe05; /* Green */
            --btn-success-hover-bg: #02fe05; /* Green */
            --btn-secondary-bg: #ff6600;
            --btn-tertiary-bg: #ff6600;
            --error-bg: #ff0000;
            --error-border: #ff0000;
            --error-text: #02fe05; /* Green instead of white */
            --info-bg: #0000ff;
            --info-border: #0000ff;
            --info-text: #02fe05; /* Green instead of white */
            --shadow-light: none;
            --shadow-medium: none;
            --stl-mesh-color: #00ffff; /* Bright cyan for high contrast */
            --stl-background: #000000; /* Keep black background */
            --stl-ambient-light: #666666; /* Reduced ambient light to prevent washing out */
            --stl-directional-light: #e6e6e6; /* Slightly dimmed directional light for better contrast */
            --stl-ambient-intensity: 0.4; /* Lower ambient light intensity */
            --stl-directional-intensity: 0.8; /* Controlled directional light intensity */
        }

        /* High contrast mode specific button styling */
        [data-theme="high-contrast"] button[type="submit"] {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] button[type="submit"]:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Generate STL button state (blue) */
        [data-theme="high-contrast"] #action-btn.generate-state {
            background: #0201fe !important; /* Blue background for generate */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #fdfe00 !important; /* Yellow border */
        }
        
        [data-theme="high-contrast"] #action-btn.generate-state:hover {
            background: #0201fe !important; /* Blue background */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #02fe05 !important; /* Green border on hover */
        }
        
        /* High contrast mode - Download STL button state (green) */
        [data-theme="high-contrast"] #action-btn.download-state {
            background: #02fe05 !important; /* Green background for download */
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }
        
        [data-theme="high-contrast"] #action-btn.download-state:hover {
            background: #02fe05 !important; /* Green background */
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }
        
        /* High contrast mode - Disabled/Loading state */
        [data-theme="high-contrast"] #action-btn:disabled {
            background: #666666 !important; /* Gray background for disabled */
            color: #cccccc !important; /* Light gray text */
            border: 2px solid #999999 !important; /* Gray border */
            cursor: not-allowed !important;
        }

        [data-theme="high-contrast"] #download-counter-plate-btn {
            background: #ff6600 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #000000 !important; /* Black border */
        }

        [data-theme="high-contrast"] #download-counter-plate-btn:hover {
            background: #ff8800 !important;
            color: #000000 !important; /* Black text */
            border: 2px solid #ffff00 !important; /* Yellow border on hover */
        }

        [data-theme="high-contrast"] .expert-toggle-btn,
        [data-theme="high-contrast"] .info-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn:hover,
        [data-theme="high-contrast"] .info-toggle-btn:hover {
            background: #000000 !important; /* Black background on hover */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .expert-toggle-btn.active,
        [data-theme="high-contrast"] .info-toggle-btn.active {
            background: #000000 !important; /* Black background when active */
            color: #02fe05 !important; /* Green text to match other menu titles */
            border: 2px solid #02fe05 !important; /* Green border */
        }

        [data-theme="high-contrast"] .font-size-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .font-size-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        [data-theme="high-contrast"] .font-size-btn.reset-btn {
            background: #2a2a2a !important; /* Darker background */
            color: #00ffff !important; /* Cyan text */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .font-size-display {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow background on hover */
            color: #000000 !important; /* Black text on hover */
            border: 2px solid #000000 !important; /* Black border on hover */
        }

        /* Apply transition to theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; /* Ensure all elements include padding/borders in width */
        }

        /* Skip Link for Keyboard Navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--border-focus);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 0 0 8px 0;
            z-index: 1000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }



        /* Font Size Controls */
        .font-size-controls {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.4em 0.6em;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .font-size-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            min-width: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px var(--shadow-medium);
        }

        .font-size-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .font-size-btn.reset-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8em;
        }

        .font-size-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 6px;
            padding: 0.4em 0.6em;
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 3.5em;
            text-align: center;
            user-select: none;
        }



        /* Enhanced focus indicators for all interactive elements */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus,
        a:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        /* Ensure proper keyboard navigation visibility */
        *:focus-visible {
            outline: 3px solid var(--border-focus) !important;
            outline-offset: 2px !important;
        }

        /* Mobile-optimized scroll containers */
        @media (max-width: 768px) {
            .main-layout {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                max-height: calc(100vh - 1em);
            }
            
            /* Sticky generate button on mobile */
            .button-row {
                position: sticky;
                bottom: 0;
                background: var(--bg-primary);
                padding: 1em 0;
                margin: 0 -1em;
                padding-left: 1em;
                padding-right: 1em;
                box-shadow: 0 -2px 8px var(--shadow-light);
                z-index: 10;
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Fieldset styling */
        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        .line-input-fieldset {
            margin: 0;
        }

        /* Braille preview styles */
        .braille-preview {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
        }

        .preview-heading {
            margin-top: 0;
            color: var(--text-primary);
        }

        .preview-line-success {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            border: 1px solid var(--border-primary);
        }

        .preview-line-error {
            margin: 10px 0;
            padding: 10px;
            background: var(--error-bg);
            border-radius: 5px;
            border: 1px solid var(--error-border);
            color: var(--error-text);
        }

        .expert-info {
            font-size: 0.9em;
            color: var(--text-tertiary);
            font-style: italic;
            margin-bottom: 1em;
            text-align: center;
        }

        /* High contrast text styling */
        [data-theme="high-contrast"] strong,
        [data-theme="high-contrast"] b {
            color: #02fe05 !important; /* Green for bold text */
        }

        [data-theme="high-contrast"] .grade-label[style*="font-weight: 700"] {
            color: #02fe05 !important; /* Green for bold labels */
        }

        [data-theme="high-contrast"] em,
        [data-theme="high-contrast"] i,
        [data-theme="high-contrast"] [style*="font-style: italic"] {
            color: #fdfe00 !important; /* Yellow for italic text */
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-info span {
            color: #fdfe00 !important; /* Yellow for grade info notes */
        }

        [data-theme="high-contrast"] #offset-help {
            color: #fdfe00 !important; /* Yellow for offset help text */
        }

        /* Note styling classes */
        .grade-note,
        .offset-note {
            color: var(--text-tertiary);
            font-style: italic;
        }

        [data-theme="high-contrast"] .grade-note,
        [data-theme="high-contrast"] .offset-note {
            color: #fdfe00 !important; /* Yellow for all note text */
        }

        body {
            background: linear-gradient(120deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            font-family: 'Inter', system-ui, Arial, sans-serif;
            margin: 0;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 2em;
            color: var(--text-primary);
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* Mobile-specific body adjustments */
        @media (max-width: 768px) {
            body {
                padding: 0.5em;
                min-height: 100vh;
                overflow-x: hidden;
            }
        }
        
        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 2em;
            background: var(--bg-primary);
            border-radius: 22px;
            box-shadow: 0 8px 32px var(--shadow-light);
            padding: 2.5em 2.5em 2.5em 2.5em;
            max-width: 1400px;
            width: 100%;
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal overflow */
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        /* Mobile layout optimization */
        @media (max-width: 768px) {
            .main-layout {
                padding: 1.5em;
                border-radius: 16px;
                gap: 1.5em;
                box-shadow: 0 4px 16px var(--shadow-light);
            }
        }
        
        @media (max-width: 480px) {
            .main-layout {
                padding: 1em;
                border-radius: 12px;
                gap: 1em;
            }
        }
        
        /* Title Section - Full Width at Top */
        .title-section {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 1.5em;
            width: 100%;
        }
        
        .title-section h1 {
            margin: 0;
            display: flex;
            flex-direction: column;
            line-height: 1.1;
        }
        
        .title-line-1 {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--text-primary); /* Default theme color */
        }
        
        .title-line-2 {
            font-size: 1.6em;
            font-weight: 600;
            color: var(--text-secondary); /* Default theme color */
            margin-top: 0.1em;
        }
        
        /* High contrast mode - bright violet title */
        [data-theme="high-contrast"] .title-line-1,
        [data-theme="high-contrast"] .title-line-2 {
            color: #fd01fc !important; /* Bright violet for high contrast mode */
        }
        
        /* Top Accessibility Controls */
        .accessibility-controls-top {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
            margin-left: 1rem;
        }
        
        /* Content Area - Two Column Layout */
        .content-area {
            display: flex;
            gap: 2.5em;
            width: 100%;
        }
        
        /* Left Column - Preview Section (45% width) */
        .preview-section {
            flex: 0 0 45%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            overflow: visible; /* Ensure rounded corners aren't cut off */
            padding-right: 1em; /* Add padding to prevent cutoff */
        }
        
        /* Right Column - Form Section (55% width) */
        .form-section {
            flex: 0 0 calc(55% - 2em); /* Subtract padding to prevent overflow */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-width: 320px;
            max-width: calc(55% - 2em); /* Prevent form from extending past background */
            overflow-x: hidden; /* Prevent horizontal overflow */
        }
        
        /* Mobile layout - stack columns */
        @media (max-width: 768px) {
            .content-area {
                flex-direction: column;
                gap: 1.5em;
            }
            
            .preview-section,
            .form-section {
                flex: none;
                width: 100%;
            }
        }

        #viewer {
            width: calc(100% - 2px); /* Account for border width */
            min-width: 320px;
            max-width: calc(100% - 2px);
            height: 420px;
            border-radius: 18px;
            border: 2px solid var(--border-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 4px 24px var(--shadow-light);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 0 1.5em 0;
            transition: box-shadow 0.2s;
            touch-action: pan-x pan-y pinch-zoom;
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden; /* Ensure content doesn't overflow rounded corners */
            box-sizing: border-box; /* Include border in size calculation */
        }
        
        /* Mobile viewer optimizations */
        @media (max-width: 768px) {
            #viewer {
                height: 280px;
                min-width: unset;
                width: 100%;
                max-width: 100%;
                border-radius: 12px;
                margin: 0 0 1em 0;
            }
        }
        
        @media (max-width: 480px) {
            #viewer {
                height: 240px;
            }
        }
        #viewer:focus-within, #viewer:active {
            box-shadow: 0 8px 32px var(--shadow-medium);
        }

        h1 {
            font-size: 2.2em;
            font-weight: 700;
            margin-bottom: 0.7em;
            color: var(--text-primary);
            text-align: left;
        }
        
        /* Mobile heading optimization */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 0.5em;
                text-align: center;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                line-height: 1.3;
            }
        }
        .info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .info-panel p {
            margin: 0.3em 0;
        }
        .grade-selection {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-bottom: 1.5em;
        }
        
        /* Mobile grade selection optimization */
        @media (max-width: 768px) {
            .grade-selection {
                padding: 1.2em;
                margin-bottom: 1.2em;
            }
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 0.6em;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.6em;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-secondary);
            padding: 0.5em 0;
            margin: -0.5em 0;
        }
        
        /* Mobile radio option optimization */
        @media (max-width: 768px) {
            .radio-option {
                padding: 0.8em 0;
                font-size: 1em;
                gap: 0.8em;
            }
            
            .radio-option input[type="radio"] {
                width: 20px;
                height: 20px;
                min-width: 20px;
                min-height: 20px;
            }
        }
        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }
        .radio-text {
            cursor: pointer;
        }
        form {
            display: flex;
            flex-direction: column;
            gap: 1.1em;
        }
        .line-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
        }
        .line-input {
            display: flex;
            align-items: center;
            gap: 0.8em;
        }
        
        /* Mobile line input optimization */
        @media (max-width: 768px) {
            .line-input {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5em;
            }
            
            .line-label {
                font-size: 0.95em;
                font-weight: 600;
                margin-bottom: 0.2em;
            }
        }
        .line-label {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
            font-size: 0.9em;
        }
        input[type="text"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            -webkit-appearance: none;
            appearance: none;
        }
        
        /* Mobile-friendly input styles */
        @media (max-width: 768px) {
            input[type="text"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
            }
        }
        input[type="text"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        /* Ensure number inputs are properly styled and functional */
        input[type="number"] {
            flex: 1;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            min-width: 80px;
            -webkit-appearance: none;
            -moz-appearance: textfield;
            appearance: none;
        }
        
        /* Remove spinner buttons */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        /* Mobile-friendly number input styles */
        @media (max-width: 768px) {
            input[type="number"] {
                padding: 1em;
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 48px;
                width: 100%;
                min-width: unset;
            }
        }
        
        input[type="number"]:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        input[type="number"]:hover {
            border-color: var(--border-primary);
        }
        
        /* Language select dropdown styling */
        .language-select {
            width: 100%;
            border: 1.5px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.8em;
            font-size: 1em;
            font-family: inherit;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border 0.2s;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%23666" d="M0 0l6 6 6-6z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.8em center;
            background-size: 12px;
            padding-right: 2.5em;
        }
        
        /* Mobile select optimization */
        @media (max-width: 768px) {
            .language-select {
                padding: 1em;
                padding-right: 3em;
                font-size: 16px;
                min-height: 48px;
            }
        }
        
        .language-select:focus {
            border: 1.5px solid var(--border-focus);
            outline: none;
            background: var(--bg-primary);
        }
        
        .language-select:hover {
            border-color: var(--border-primary);
        }
        
        /* High contrast mode select styling */
        [data-theme="high-contrast"] .language-select {
            background: #1a1a1a !important;
            color: #ffffff !important;
            border: 2px solid #ffff00 !important;
        }
        
        [data-theme="high-contrast"] .language-select:focus {
            background: #2a2a2a !important;
            color: #ffffff !important;
            border: 2px solid #ff00ff !important;
        }
        
        [data-theme="high-contrast"] .language-select option {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }
        
        [data-theme="high-contrast"] .language-select optgroup {
            background: #2a2a2a !important;
            color: #ffff00 !important;
            font-weight: bold;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            margin-top: 1em;
        }
        button {
            border: none;
            border-radius: 8px;
            padding: 0.7em 1em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            line-height: 1.2;
            white-space: nowrap;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        /* Mobile-friendly button styles */
        @media (max-width: 768px) {
            button {
                padding: 1em 1.2em;
                font-size: 1.1em;
                min-height: 48px;
                min-width: 48px;
            }
        }
        button[type="submit"] {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        button[type="submit"]:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        /* Action button state styles */
        #action-btn {
            transition: all 0.3s ease;
            min-width: 140px;
            text-align: center;
            font-size: 0.95em;
        }
        
        #action-btn.generate-state {
            background: var(--btn-primary-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.generate-state:hover {
            background: var(--btn-primary-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        #action-btn.download-state {
            background: var(--btn-success-bg);
            color: #fff;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        #action-btn.download-state:hover {
            background: var(--btn-success-hover-bg);
            transform: translateY(-2px) scale(1.03);
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            margin-bottom: 1em;
            flex-wrap: wrap;
        }
        
        /* Mobile button row optimization */
        @media (max-width: 768px) {
            .button-row {
                gap: 0.8em;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }


        #download-counter-plate-btn {
            background: var(--btn-tertiary-bg);
            color: #fff;
        }
        #download-counter-plate-btn:hover {
            background: var(--btn-tertiary-bg);
            opacity: 0.9;
            transform: translateY(-2px) scale(1.03);
        }
        #error-message {
            color: var(--error-text);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 6px;
            padding: 0.7em 1em;
            margin-top: 0.5em;
            font-size: 1em;
            display: none;
            align-items: center;
            gap: 0.5em;
        }
        
        #error-message.info {
            color: var(--info-text);
            background: var(--info-bg);
            border: 1px solid var(--info-border);
        }
        
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        
        .expert-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5em;
            transition: background 0.2s, border-color 0.2s;
            width: 100%;
        }
        
        .expert-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        
        .expert-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .expert-toggle-btn.active #expert-toggle-text {
            color: #fff;
        }
        
        .expert-toggle-btn.active #expert-toggle-icon {
            transform: rotate(180deg);
        }
        
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        /* Ensure Expert Mode inputs are properly spaced and visible */
        .expert-settings .grade-selection {
            margin-bottom: 1em;
        }
        
        .expert-settings input[type="number"] {
            margin-top: 0.3em;
            margin-bottom: 0.5em;
        }
        
        .expert-settings label {
            display: block;
            margin-bottom: 0.3em;
            font-weight: 500;
            color: var(--text-primary);
        }
        .expert-mode-toggle {
            margin-top: 1em;
            text-align: center;
        }
        .expert-settings {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-primary);
        }
        
        .info-dropdown {
            margin-bottom: 1.5em;
        }
        
        .info-toggle-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.8em 1em;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .info-toggle-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-secondary);
        }
        
        .info-toggle-btn.active {
            background: var(--border-focus);
            color: #fff;
            border-color: var(--border-focus);
        }
        
        .info-toggle-btn.active #info-toggle-text {
            color: #fff;
        }
        
        .info-toggle-btn.active #info-toggle-icon {
            transform: rotate(180deg);
        }
        
        .info-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 1em;
            margin-top: 0.5em;
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .info-content p {
            margin: 0.3em 0;
        }
        
        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .viewer-section, .form-section {
                max-width: 100%;
                min-width: unset;
            }
            
            .info-panel, .info-content {
                padding: 1.2em;
                font-size: 0.95em;
            }
            
            .info-toggle-btn, .expert-toggle-btn {
                padding: 1em;
                font-size: 1em;
                min-height: 48px;
            }
            
            #error-message {
                padding: 1em;
                font-size: 0.95em;
                margin: 0.8em 0;
            }
            
            .button-group {
                gap: 0.8em;
            }
            
            /* Ensure scroll behavior is smooth on mobile */
            html {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            .expert-settings input[type="number"] {
                width: 100%;
            }
            
            .font-size-controls {
                transform: scale(0.9);
                transform-origin: top right;
            }
        }
        

        
        /* Plate Selection Row Layout */
        .plate-selection-row {
            display: flex;
            align-items: flex-start;
            gap: 1.5em;
            margin-top: 1em;
        }
        
        .plate-type-selection {
            flex: 1;
            min-width: 250px;
        }
        
        .button-row {
            display: flex;
            gap: 1em;
            align-items: center;
            flex-shrink: 0;
        }
        
        /* Mobile plate selection row optimization */
        @media (max-width: 768px) {
            .plate-selection-row {
                flex-direction: column;
                gap: 1em;
            }
            
            .plate-type-selection {
                min-width: unset;
                width: 100%;
            }
            
            .button-row {
                width: 100%;
                justify-content: stretch;
            }
            
            .button-row button {
                flex: 1;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            .button-row {
                flex-direction: column;
                gap: 0.8em;
            }
            
            .button-row button {
                width: 100%;
                min-width: unset;
            }
        }

        /* Theme Toggle Section */
        .theme-toggle-section {
            display: flex;
            align-items: center;
            gap: 0.8em;
            margin-left: auto;
        }

        .theme-label-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            color: var(--text-secondary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.3em;
            min-height: 2.5em;
            box-sizing: border-box;
        }

        .theme-label-text {
            font-weight: 600;
            color: var(--text-secondary);
        }

        /* Theme Toggle Button */
        .theme-toggle-btn {
            background: var(--bg-primary);
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            padding: 0.6em 1em;
            font-size: 0.9em;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5em;
            transition: all 0.2s;
            box-shadow: 0 2px 8px var(--shadow-light);
        }

        .theme-toggle-btn:hover {
            background: var(--bg-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }

        .theme-toggle-btn:focus {
            outline: 3px solid var(--border-focus);
            outline-offset: 2px;
        }

        .theme-icon {
            font-size: 1.2em;
        }

        /* Mobile title section optimization */
        @media (max-width: 768px) {
            .title-section {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 1rem;
                margin-bottom: 1em;
            }
            
            .title-section h1 {
                text-align: center;
            }
            
            .title-line-1 {
                font-size: 1.5em;
            }
            
            .title-line-2 {
                font-size: 1.3em;
            }
            
            .accessibility-controls-top {
                margin-left: 0;
                align-items: center;
            }
            
            .theme-toggle-section {
                flex-direction: column;
                align-items: center;
                gap: 0.5em;
                margin-left: 0;
            }
            
            .theme-label-box {
                font-size: 0.85em;
                min-height: 2.2em;
            }
        }
        
        @media (max-width: 480px) {
            .title-line-1 {
                font-size: 1.3em;
            }
            
            .title-line-2 {
                font-size: 1.1em;
            }
        }
        
        /* Form Section Accessibility Controls */
        [data-theme="high-contrast"] .theme-label-box {
            background: #1a1a1a !important; /* Dark background for high contrast */
            border: 2px solid #ffff00 !important; /* Yellow border for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-label-text {
            color: #02fe05 !important; /* Green text for high contrast */
        }
        
        [data-theme="high-contrast"] .theme-toggle-btn:hover {
            background: #ffff00 !important; /* Yellow instead of yellow */
            color: #0201fe !important; /* Blue instead of black */
            border: 2px solid #0201fe !important; /* Blue instead of black */
        }

        [data-theme="high-contrast"] input[type="text"],
        [data-theme="high-contrast"] input[type="number"] {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] input[type="text"]:focus,
        [data-theme="high-contrast"] input[type="number"]:focus {
            background: #0201fe !important; /* Blue background for inputs */
            color: #fdfe00 !important; /* Yellow text */
            border: 2px solid #ff00ff !important; /* Magenta border on focus */
        }

        [data-theme="high-contrast"] .info-panel,
        [data-theme="high-contrast"] .grade-selection,
        [data-theme="high-contrast"] .info-content {
            background: #1a1a1a !important; /* Dark background for panels */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .braille-preview {
            background: #1a1a1a !important; /* Dark background */
            color: #ffff00 !important; /* Yellow text */
            border: 2px solid #ffff00 !important; /* Yellow border */
        }

        [data-theme="high-contrast"] .preview-line-success {
            background: #2a2a2a !important; /* Darker background */
            color: #02fe05 !important; /* Green text for success */
            border: 2px solid #00ffff !important; /* Cyan border */
        }

        [data-theme="high-contrast"] .preview-line-error {
            background: #ff0000 !important;
            color: #02fe05 !important; /* Green text */
            border: 2px solid #ff0000 !important;
        }

        /* Section Title Styling - Larger Font for All Themes */
        .info-panel strong,
        .info-panel p strong {
            font-size: 1.3em !important;
            font-weight: 700 !important;
        }
        
        #info-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }
        
        .grade-label {
            font-weight: 600;
            color: var(--text-primary);
            display: block;
            margin-bottom: 0.8em;
            font-size: 1.2em !important; /* Increased from 0.9em */
        }
        
        .expert-toggle-btn #expert-toggle-text {
            font-size: 1.2em !important;
            font-weight: 600 !important;
        }
    </style>
</head>
<body>
    <!-- Skip Navigation Link for Keyboard Users -->
    <a href="#main-content" class="skip-link" tabindex="0">Skip to main content</a>
    

    
    <div class="main-layout" role="main" id="main-content">
        <!-- Title Section at the top -->
        <div class="title-section">
            <h1 id="main-heading">
                <span class="title-line-1">Braille Business</span>
                <span class="title-line-2">Card STL Generator</span>
            </h1>
            
            <!-- Accessibility Controls in top right -->
            <div class="accessibility-controls-top" role="group" aria-label="Accessibility controls">
                <!-- Font Size Controls -->
                <div class="font-size-controls" role="group" aria-label="Font size adjustment">
                    <button id="font-decrease" class="font-size-btn" aria-label="Decrease font size" title="Decrease font size">
                        <span aria-hidden="true">A-</span>
                        <span class="sr-only">Decrease font size</span>
                    </button>
                    <span class="font-size-display" aria-label="Current font size">
                        <span id="current-font-size">100</span>%
                    </span>
                    <button id="font-increase" class="font-size-btn" aria-label="Increase font size" title="Increase font size">
                        <span aria-hidden="true">A+</span>
                        <span class="sr-only">Increase font size</span>
                    </button>
                    <button id="font-reset" class="font-size-btn reset-btn" aria-label="Reset font size to default" title="Reset font size to default">
                        <span aria-hidden="true">⟲</span>
                        <span class="sr-only">Reset font size</span>
                    </button>
                </div>
                
                <!-- Theme Toggle Section -->
                <div class="theme-toggle-section" role="group" aria-labelledby="theme-label">
                    <div id="theme-label" class="theme-label-box">
                        <span class="theme-label-text">Change Theme to →</span>
                    </div>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle theme" title="Toggle between light, dark, and high contrast themes">
                        <span class="theme-icon" aria-hidden="true">⚡</span>
                        <span class="theme-text">High Contrast</span>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area - Two Column Layout -->
        <div class="content-area">
            <!-- Left Column - STL Preview Section (45% width) -->
            <div class="preview-section" role="region" aria-label="3D STL Preview">
                <div id="viewer" role="img" aria-label="3D preview of braille business card STL file" tabindex="0"></div>
                
                <!-- Text Input Section moved here -->
                <div class="line-input-group">
                    <fieldset class="line-input-fieldset">
                        <legend class="grade-label">Enter Text for Braille Translation</legend>
                        <div class="grade-note" style="margin-bottom: 0.8em; font-size: 0.85em;">
                            <strong>Note:</strong> Contracted braille combines letters into single cells, so the character limit is only confirmed <em>after translation</em> — the program will warn you automatically if it's too long.
                        </div>
                        <!-- Dynamic line inputs container -->
                        <div id="dynamic-line-inputs">
                            <!-- Line inputs will be dynamically generated here based on grid_rows value -->
                        </div>
                    </fieldset>
                </div>
                
                <!-- Action Button moved here -->
                <div class="button-row" style="margin-top: 1em;">
                    <button type="button" id="action-btn" class="generate-state" aria-label="Generate STL file from entered text" data-state="generate">Generate STL</button>
                </div>
            </div>
            
            <!-- Right Column - Form Controls Section (55% width) -->
            <div class="form-section" role="region" aria-label="Braille Card Configuration">
                <div class="info-panel">
                    <p><strong>Program Description:</strong></p>
                    <p>Creates two matching STLs for a standard 3.5″ × 2″ card.</p>
                    <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                        <li><strong>Embossing Plate</strong> (cone dots)</li>
                        <li><strong>Universal Counter Plate</strong> (hemispherical recessed dots)</li>
                    </ol>
                </div>
                
                <div class="info-dropdown">
                    <button type="button" id="info-toggle" class="info-toggle-btn">
                        <span id="info-toggle-text">More Info</span>
                        <span id="info-toggle-icon">▼</span>
                    </button>
                    <div id="info-content" class="info-content" style="display: none;">
                        <p><strong>Instructions:</strong></p>
                        <ol style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Enter up to <strong>4 lines</strong> of English text, then click <strong>"Generate STL."</strong> The app auto-translates to <strong>Unified English Braille (UEB)</strong>.</li>
                            <li>Review the 3D preview. If it looks correct, click <strong>"Download STL."</strong></li>
                            <li>Click <strong>"Universal Counter Plate"</strong> and repeat the steps to generate and download the matching counter plate (if you haven't printed one yet).</li>
                            <li>Need specific dimensions? Open <strong>Expert Mode</strong> to adjust card size, spacing, and dot parameters.</li>
                        </ol>
                        <p><strong>Acknowledgements:</strong></p>
                        <ul style="margin: 0.3em 0; padding-left: 1.5em;">
                            <li>Powered by <a href="https://liblouis.io/" target="_blank" style="color: #3182ce; text-decoration: none;"><strong>Liblouis</strong></a>, an open-source professional braille translator.</li>
                            <li>Extra thanks to <strong>Tobi Weinberg</strong> for the substantial time and effort he volunteered to help start this project and see it through.</li>
                        </ul>
                    </div>
                </div>
                
                <div id="error-message" role="alert" aria-live="assertive" aria-atomic="true">
                    <span style="font-weight:bold;" aria-hidden="true">⚠</span> 
                    <span id="error-text"></span>
                </div>
                
                <form id="braille-form" aria-labelledby="main-heading">
                    <!-- Language Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Language:</legend>
                            <div style="margin-bottom: 0.8em;">
                                <select id="language-table" name="language_table" class="language-select" aria-describedby="language-help">
                                    <!-- Default English options -->
                                    <optgroup label="Default">
                                        <option value="en-ueb-g2.ctb" selected>English, U.S., contracted (UEB grade 2)</option>
                                        <option value="en-ueb-g1.ctb">English, U.S., uncontracted (UEB grade 1)</option>
                                        <option value="en-us-g2.ctb">English, U.S., contracted (EBAE grade 2)</option>
                                        <option value="en-us-g1.ctb">English, U.S., uncontracted (EBAE grade 1)</option>
                                        <option value="en-GB-g2.ctb">English, U.K., contracted (grade 2)</option>
                                        <option value="en-gb-g1.utb">English, U.K., uncontracted (grade 1)</option>
                                        <option value="en_CA.ctb">English, Canada, computer braille</option>
                                    </optgroup>
                                    <!-- All other languages -->
                                    <optgroup label="Other">
                                        <option value="afr-za-g1.ctb">Afrikaans, South Africa</option>
                                        <option value="ar-ar-g1.utb">Arabic</option>
                                        <option value="bg.ctb">Bulgarian</option>
                                        <option value="zh-chn.ctb">Chinese, China (simplified)</option>
                                        <option value="zh-tw.ctb">Chinese, Taiwan (traditional)</option>
                                        <option value="hr.ctb">Croatian</option>
                                        <option value="cs-g1.ctb">Czech, uncontracted</option>
                                        <option value="da-dk-g26.ctb">Danish, contracted (6-dot)</option>
                                        <option value="da-dk-g16.ctb">Danish, uncontracted (6-dot)</option>
                                        <option value="nl-NL-g0.utb">Dutch, Netherlands, uncontracted</option>
                                        <option value="eo-g1.ctb">Esperanto</option>
                                        <option value="fa-ir-g1.utb">Persian/Farsi, Iran</option>
                                        <option value="fi-fi.ctb">Finnish, 6-dot</option>
                                        <option value="fr-fr-g1.utb">French, France, uncontracted (grade 1)</option>
                                        <option value="Fr-Fr-g2.ctb">French, France, contracted (grade 2)</option>
                                        <option value="de-de-g1.ctb">German, Germany, uncontracted (grade 1)</option>
                                        <option value="de-de-g2.ctb">German, Germany, contracted (grade 2)</option>
                                        <option value="el.ctb">Greek</option>
                                        <option value="he.ctb">Hebrew</option>
                                        <option value="hi-in-g1.utb">Hindi, India</option>
                                        <option value="hu-hu-g1.ctb">Hungarian, uncontracted (grade 1)</option>
                                        <option value="hu-hu-g2.ctb">Hungarian, contracted (grade 2)</option>
                                        <option value="is.ctb">Icelandic</option>
                                        <option value="ga-g1.utb">Irish, uncontracted (grade 1)</option>
                                        <option value="ga-g2.ctb">Irish, contracted (grade 2)</option>
                                        <option value="it-it-comp6.utb">Italian, computer braille (6-dot)</option>
                                        <option value="it-it-comp8.utb">Italian, computer braille (8-dot)</option>
                                        <option value="ko-g1.ctb">Korean, uncontracted (grade 1)</option>
                                        <option value="ko-g2.ctb">Korean, contracted (grade 2)</option>
                                        <option value="mt.ctb">Maltese</option>
                                        <option value="no-no-g1.ctb">Norwegian, uncontracted (grade 1)</option>
                                        <option value="no-no-g2.ctb">Norwegian, contracted (grade 2)</option>
                                        <option value="Pl-Pl-g1.utb">Polish, uncontracted</option>
                                        <option value="pl-pl-comp8.ctb">Polish, computer braille (8-dot)</option>
                                        <option value="pt-pt-g1.utb">Portuguese, Portugal, uncontracted (grade 1)</option>
                                        <option value="pt-pt-g2.ctb">Portuguese, Portugal, contracted (grade 2)</option>
                                        <option value="ro.ctb">Romanian</option>
                                        <option value="ru-ru-g1.utb">Russian, uncontracted</option>
                                        <option value="ru-litbrl.ctb">Russian, literary</option>
                                        <option value="gd.ctb">Scottish Gaelic</option>
                                        <option value="sr-g1.ctb">Serbian</option>
                                        <option value="sk-sk-g1.utb">Slovak, uncontracted</option>
                                        <option value="sl-si-g1.utb">Slovenian, uncontracted</option>
                                        <option value="sl-si-comp8.ctb">Slovenian, computer braille (8-dot)</option>
                                        <option value="Es-Es-g1.utb">Spanish, Spain, uncontracted</option>
                                        <option value="sv-1996.ctb">Swedish (1996 standard)</option>
                                        <option value="tr.ctb">Turkish, contracted</option>
                                        <option value="tr-g1.ctb">Turkish, uncontracted (grade 1)</option>
                                        <option value="vi.ctb">Vietnamese, contracted</option>
                                        <option value="vi-g1.ctb">Vietnamese, uncontracted (grade 1)</option>
                                        <option value="cy-cy-g1.utb">Welsh, uncontracted (grade 1)</option>
                                        <option value="cy-cy-g2.ctb">Welsh, contracted (grade 2)</option>
                                    </optgroup>
                                </select>
                                <div id="language-help" class="grade-note" style="margin-top: 6px; font-size: 0.85em;">
                                    NOTE: English, U.S., contracted (UEB grade 2) is the default standard for all U.S. English braille translations. Please only select another language or grade for special use cases.
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                    <!-- Plate Type Selection moved here -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Plate to Generate</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="positive" checked aria-describedby="emboss-plate-desc">
                                    <span class="radio-text">Embossing Plate</span>
                                </label>
                                <span id="emboss-plate-desc" class="sr-only">Creates raised braille dots for embossing cards</span>
                                <label class="radio-option">
                                    <input type="radio" name="plate_type" value="negative" aria-describedby="counter-plate-desc">
                                    <span class="radio-text">Universal Counter Plate</span>
                                </label>
                                <span id="counter-plate-desc" class="sr-only">Creates recessed dots to support embossing process</span>

                            </div>
                        </fieldset>
                    </div>
                    
                    <!-- Output Shape Selection -->
                    <div class="grade-selection">
                        <fieldset>
                            <legend class="grade-label">Select Output Shape</legend>
                            <div class="radio-group" role="radiogroup" aria-required="true">
                                <label class="radio-option">
                                    <input type="radio" name="shape_type" value="card" checked aria-describedby="card-shape-desc">
                                    <span class="radio-text">Flat Card</span>
                                </label>
                                <span id="card-shape-desc" class="sr-only">Creates a flat rectangular braille card</span>
                                <label class="radio-option">
                                    <input type="radio" name="shape_type" value="cylinder" aria-describedby="cylinder-shape-desc">
                                    <span class="radio-text">Cylinder</span>
                                </label>
                                <span id="cylinder-shape-desc" class="sr-only">Creates a cylindrical braille surface</span>
                            </div>
                        </fieldset>
                    </div>
                    


                    <div class="expert-mode-toggle">
                        <button type="button" id="expert-toggle" class="expert-toggle-btn">
                            <span id="expert-toggle-text">Show Expert Mode</span>
                            <span id="expert-toggle-icon">▼</span>
                        </button>
                    </div>

                    <div id="expert-settings" class="expert-settings" style="display: none;">
                        <div class="expert-info" role="note" aria-label="Expert mode information">
                            Any changes made here will affect both plates.
                        </div>
                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille Dimensions</label>
                            <div>
                                <label for="grid_columns">Number of Braille Cells (Characters):</label>
                                <input type="number" id="grid_columns" name="grid_columns" value="13">
                            </div>
                            <div>
                                <label for="grid_rows">Number of Braille Lines:</label>
                                <input type="number" id="grid_rows" name="grid_rows" value="4">
                            </div>
                            <div>
                                <label for="cell_spacing">Braille Cell Spacing:</label>
                                <input type="number" id="cell_spacing" name="cell_spacing" value="6.5" step="0.1">
                            </div>
                            <div>
                                <label for="line_spacing">Braille Line Spacing:</label>
                                <input type="number" id="line_spacing" name="line_spacing" value="10.0" step="0.1">
                            </div>
                            <div>
                                <label for="dot_spacing">Braille Dot Spacing:</label>
                                <input type="number" id="dot_spacing" name="dot_spacing" value="2.5" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Dot Dimensions</label>
                            <div>
                                <label for="emboss_dot_base_diameter">Dot diameter:</label>
                                <input type="number" id="emboss_dot_base_diameter" name="emboss_dot_base_diameter" value="1.8" step="0.1">
                            </div>
                            <div>
                                <label for="emboss_dot_height">Dot height:</label>
                                <input type="number" id="emboss_dot_height" name="emboss_dot_height" value="1.0" step="0.1">
                            </div>
                            <div>
                                <label for="emboss_dot_flat_hat">Flat hat diameter:</label>
                                <input type="number" id="emboss_dot_flat_hat" name="emboss_dot_flat_hat" value="0.4" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Counter Dot Dimensions</label>
                            <div>
                                <label for="counter_plate_dot_size_offset">Counter Dot Diameter Offset (mm):</label>
                                <input type="number" id="counter_plate_dot_size_offset" name="counter_plate_dot_size_offset" value="0.0" step="0.1" aria-describedby="offset-help" title="Adjusts the counter plate braille dot base diameter relative to the emboss plate diameter">
                                <div id="offset-help" class="offset-note" style="font-size: 0.85em; margin-top: 2px;">
                                    Adds or subtracts from the Universal Counter Plate's recessed dot diameter. The dot size mirrors the Embossing Plate's Dot Base Diameter by default.
                                </div>
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Plate Dimensions</label>
                            <div>
                                <label for="card_width">Plate Width:</label>
                                <input type="number" id="card_width" name="card_width" value="90" step="0.1">
                            </div>
                            <div>
                                <label for="card_height">Plate Height:</label>
                                <input type="number" id="card_height" name="card_height" value="52" step="0.1">
                            </div>
                            <div>
                                <label for="card_thickness">Plate Thickness:</label>
                                <input type="number" id="card_thickness" name="card_thickness" value="2.0" step="0.1">
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Cylinder Dimensions</label>
                            <div>
                                <label for="cylinder_diameter_mm">Cylinder Diameter (mm):</label>
                                <input type="number" id="cylinder_diameter_mm" name="cylinder_diameter_mm" value="30" step="0.1" min="10" max="200">
                            </div>
                            <div>
                                <label for="cylinder_height_mm">Cylinder Height (mm):</label>
                                <input type="number" id="cylinder_height_mm" name="cylinder_height_mm" value="52" step="0.1" min="10" max="200">
                            </div>
                            <div>
                                <label for="cylinder_polygonal_cutout_radius_mm">Polygonal Cutout Inscribed Radius (mm):</label>
                                <input type="number" id="cylinder_polygonal_cutout_radius_mm" name="cylinder_polygonal_cutout_radius_mm" value="13" step="0.1" min="0" max="50">
                                <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                    Creates a 12-point polygonal cutout along the cylinder's length. Set to 0 for no cutout.
                                </div>
                            </div>
                            <div>
                                <label for="seam_offset_deg">Seam Offset (degrees):</label>
                                <input type="number" id="seam_offset_deg" name="seam_offset_deg" value="0" step="1" min="0" max="360">
                                <div class="grade-note" style="margin-top: 4px; font-size: 0.85em;">
                                    Rotates the starting position of braille text around the cylinder
                                </div>
                            </div>
                            <div id="cylinder-overflow-warning" class="grade-note" style="margin-top: 10px; color: #d73502; display: none;">
                                <strong>Warning:</strong> <span id="cylinder-overflow-message"></span>
                            </div>
                        </div>

                        <div class="grade-selection">
                            <label class="grade-label" style="font-size: 1.2em; font-weight: 700;">Braille / Card Positioning</label>
                            <div>
                                <label for="braille_y_adjust">Y Adjust:</label>
                                <input type="number" id="braille_y_adjust" name="braille_y_adjust" value="0.0" step="0.1">
                            </div>
                            <div>
                                <label for="braille_x_adjust">X Adjust:</label>
                                <input type="number" id="braille_x_adjust" name="braille_x_adjust" value="0.0" step="0.1">
                            </div>
                        </div>
                        
                        <div style="margin-top: 1.5em; text-align: center;">
                            <button type="button" id="preview-braille-btn">Preview Braille Translation</button>
                        </div>
                    </div>

                    <div class="button-group">
                        <!-- Test buttons removed as they are no longer needed -->
                    </div>
                </form>
                
                <div id="braille-preview" class="braille-preview" style="display: none;" role="region" aria-label="Braille translation preview">
                    <h3 class="preview-heading">Braille Translation Preview:</h3>
                    <div id="preview-content"></div>
                </div>
            </div>
        </div>
    </div>
    

    
    <!-- Load the real liblouis JavaScript implementation from static files -->
    <script src="/static/liblouis/build-no-tables-utf16.js"></script>
    <script src="/static/liblouis/easy-api.js"></script>
    
    <script type="module">
        import * as THREE from '/static/three.module.js';
        import { STLLoader } from '/static/STLLoader.js';
        import { OrbitControls } from '/static/OrbitControls.js';

        // Declare 3D scene variables at module scope
        let renderer, scene, camera, mesh, controls;
        let lastSTLUrl = null;
        
        // Production logging - only log errors in production
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const log = {
            debug: isProduction ? () => {} : console.log,
            info: isProduction ? () => {} : console.log,
            error: console.error // Always log errors
        };

        // Theme switching functionality
        const themes = ['dark', 'high-contrast', 'light'];
        const themeIcons = {
            'dark': '🌙',
            'high-contrast': '⚡',
            'light': '🌞'
        };
        const themeNames = {
            'dark': 'Dark',
            'high-contrast': 'High Contrast',
            'light': 'Light'
        };
        
        let currentThemeIndex = 0;
        const savedTheme = localStorage.getItem('preferred-theme');
        if (savedTheme && themes.includes(savedTheme)) {
            currentThemeIndex = themes.indexOf(savedTheme);
            applyTheme(savedTheme);
        } else {
            // Default to dark mode if no saved preference
            applyTheme('dark');
        }

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = themeToggle.querySelector('.theme-icon');
            const themeText = themeToggle.querySelector('.theme-text');
            
            // Find the next theme in the cycle
            const currentIndex = themes.indexOf(theme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const nextTheme = themes[nextIndex];
            
            // Show the next theme that will be applied when clicked
            themeIcon.textContent = themeIcons[nextTheme];
            themeText.textContent = themeNames[nextTheme];
            
            // Update aria-label to show current theme and what will happen next
            themeToggle.setAttribute('aria-label', `Current theme: ${themeNames[theme]}. Click to switch to ${themeNames[nextTheme]} theme`);
            
            // Save preference
            localStorage.setItem('preferred-theme', theme);
            
            // Announce theme change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Theme changed to ${themeNames[theme]}`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
            
            // Update 3D scene colors for new theme
            update3DSceneColors();
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(themes[currentThemeIndex]);
        });

        // Function to update 3D scene colors when theme changes
        function update3DSceneColors() {
            if (typeof scene !== 'undefined' && scene && typeof renderer !== 'undefined' && renderer) {
                const styles = getComputedStyle(document.documentElement);
                const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
                const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
                const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
                const stlMeshColor = styles.getPropertyValue('--stl-mesh-color').trim() || '#6699cc';
                const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
                const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
                
                // Update scene background
                scene.background = new THREE.Color(stlBackground);
                
                // Remove existing lights to rebuild them with proper configuration
                const lightsToRemove = scene.children.filter(child => 
                    child instanceof THREE.DirectionalLight || child instanceof THREE.AmbientLight
                );
                lightsToRemove.forEach(light => scene.remove(light));
                
                // Rebuild lighting based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
                
                if (currentTheme === 'high-contrast') {
                    // High contrast mode: multiple light sources for better visibility
                    directionalLight.position.set(1, 1, 1).normalize();
                    scene.add(directionalLight);
                    
                    // Add secondary fill light for high contrast
                    const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                    fillLight.position.set(-1, -0.5, 0.5).normalize();
                    scene.add(fillLight);
                } else {
                    // Standard lighting for normal modes
                    directionalLight.position.set(0, 0, 1).normalize();
                    scene.add(directionalLight);
                }
                
                // Add ambient light
                scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
                
                // Update mesh color and material properties if mesh exists
                if (mesh && mesh.material) {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    mesh.material.color = new THREE.Color(stlMeshColor);
                    
                    // Update specular properties for high contrast mode
                    if (currentTheme === 'high-contrast') {
                        mesh.material.specular = new THREE.Color(0xffffff); // White specular highlights
                        mesh.material.shininess = 300; // Higher shininess for sharper highlights
                    } else {
                        mesh.material.specular = new THREE.Color(0x111111); // Standard specular
                        mesh.material.shininess = 200; // Standard shininess
                    }
                    
                    mesh.material.needsUpdate = true;
                }
                
                // Force a re-render
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            }
        }

        // Theme initialization is handled above in the main theme logic

        // Font size adjustment functionality
        const fontSizes = [75, 87.5, 100, 112.5, 125, 150, 175, 200];
        let currentFontSizeIndex = 2; // Start at 100%
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Load saved font size preference
        const savedFontSize = localStorage.getItem('preferred-font-size');
        if (savedFontSize && !isMobile) {
            // Only use saved preference on desktop
            currentFontSizeIndex = fontSizes.indexOf(parseInt(savedFontSize));
            if (currentFontSizeIndex === -1) currentFontSizeIndex = 2;
        } else if (isMobile) {
            // Mobile defaults to 100% unless user has specifically set mobile preference
            const savedMobileFontSize = localStorage.getItem('preferred-mobile-font-size');
            if (savedMobileFontSize) {
                currentFontSizeIndex = fontSizes.indexOf(parseInt(savedMobileFontSize));
                if (currentFontSizeIndex === -1) currentFontSizeIndex = 2; // Default to 100% on mobile
            } else {
                currentFontSizeIndex = 2; // Default to 100% on mobile
            }
        }
        
        function applyFontSize(sizeIndex) {
            const size = fontSizes[sizeIndex];
            document.documentElement.style.fontSize = size + '%';
            document.getElementById('current-font-size').textContent = size;
            currentFontSizeIndex = sizeIndex;
            
            // Save preference with device-specific key
            if (window.innerWidth <= 768) {
                localStorage.setItem('preferred-mobile-font-size', size);
            } else {
                localStorage.setItem('preferred-font-size', size);
            }
            
            // Announce font size change to screen readers
            const announcement = document.createElement('div');
            announcement.className = 'sr-only';
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.textContent = `Font size changed to ${size}%`;
            document.body.appendChild(announcement);
            setTimeout(() => announcement.remove(), 1000);
        }
        
        // Initialize font size
        applyFontSize(currentFontSizeIndex);
        
        // Font size control event listeners
        document.getElementById('font-decrease').addEventListener('click', () => {
            if (currentFontSizeIndex > 0) {
                applyFontSize(currentFontSizeIndex - 1);
            }
        });
        
        document.getElementById('font-increase').addEventListener('click', () => {
            if (currentFontSizeIndex < fontSizes.length - 1) {
                applyFontSize(currentFontSizeIndex + 1);
            }
        });
        
        document.getElementById('font-reset').addEventListener('click', () => {
            applyFontSize(2); // Reset to 100%
        });

        const form = document.getElementById('braille-form');
        const viewer = document.getElementById('viewer');
        const actionBtn = document.getElementById('action-btn');
        let lastGeneratedSTLUrl = null;
        let lastGeneratedFilename = null;

        const previewBrailleBtn = document.getElementById('preview-braille-btn');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        
        // Function to reset button to generate state
        function resetToGenerateState() {
            actionBtn.textContent = 'Generate STL';
            actionBtn.className = 'generate-state';
            actionBtn.setAttribute('data-state', 'generate');
            actionBtn.setAttribute('aria-label', 'Generate STL file from entered text');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Function to set button to download state
        function setToDownloadState() {
            actionBtn.textContent = 'Download STL';
            actionBtn.className = 'download-state';
            actionBtn.setAttribute('data-state', 'download');
            actionBtn.setAttribute('aria-label', 'Download generated STL file');
            actionBtn.style.opacity = '1';
            actionBtn.disabled = false;
        }
        
        // Store the current plate type for download naming
        let currentPlateType = 'positive';
        
        // Add event handler for the action button
        actionBtn.addEventListener('click', () => {
            if (actionBtn.getAttribute('data-state') === 'generate') {
                form.dispatchEvent(new Event('submit'));
            } else if (actionBtn.getAttribute('data-state') === 'download') {
                // Download the generated STL
                if (lastGeneratedSTLUrl) {
                    const a = document.createElement('a');
                    a.href = lastGeneratedSTLUrl;
                    // Use the filename generated on the frontend
                    if (lastGeneratedFilename) {
                        a.download = lastGeneratedFilename;
                    }
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            }
        });
        const expertToggleBtn = document.getElementById('expert-toggle');
        const expertSettings = document.getElementById('expert-settings');
        const expertToggleText = document.getElementById('expert-toggle-text');
        const expertToggleIcon = document.getElementById('expert-toggle-icon');
        const braillePreview = document.getElementById('braille-preview');
        const previewContent = document.getElementById('preview-content');
        const infoToggleBtn = document.getElementById('info-toggle');
        const infoContent = document.getElementById('info-content');
        const infoToggleText = document.getElementById('info-toggle-text');
        const infoToggleIcon = document.getElementById('info-toggle-icon');



        // Add event listeners to reset button state when inputs change
        function addInputChangeListeners() {
            // Dynamic text input fields
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                if (input) {
                    // Remove existing listener to prevent duplicates
                    input.removeEventListener('input', resetToGenerateState);
                    input.addEventListener('input', resetToGenerateState);
                }
            }
            
            // Language selection
            const languageSelect = document.getElementById('language-table');
            if (languageSelect) {
                languageSelect.addEventListener('change', resetToGenerateState);
            }
            
            // Plate type radio buttons
            document.querySelectorAll('input[name="plate_type"]').forEach(radio => {
                radio.addEventListener('change', resetToGenerateState);
            });
            
            // Shape type radio buttons
            document.querySelectorAll('input[name="shape_type"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    resetToGenerateState();
                    updateShapeSettings();
                });
            });
            
            // Counter plate offset
            const counterPlateOffset = document.getElementById('counter_plate_dot_size_offset');
            if (counterPlateOffset) {
                counterPlateOffset.addEventListener('input', resetToGenerateState);
            }
            
            // Expert mode parametric dials
            const expertInputs = [
                'emboss_dot_base_diameter',
                'emboss_dot_height', 
                'emboss_dot_flat_hat',
                'counter_plate_dot_size_offset',
                'grid_columns',
                'grid_rows',
                'cell_spacing',
                'line_spacing',
                'dot_spacing',
                'card_width',
                'card_height',
                'card_thickness',
                'braille_x_adjust',
                'braille_y_adjust'
            ];
            
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', resetToGenerateState);
                }
            });
            
            // Cylinder parameter inputs
            const cylinderInputs = [
                'cylinder_diameter_mm',
                'cylinder_height_mm',
                'cylinder_polygonal_cutout_radius_mm',
                'seam_offset_deg'
            ];
            
            cylinderInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        resetToGenerateState();
                        checkCylinderOverflow();
                    });
                }
            });
        }
        
        // Function to show/hide cylinder settings based on shape selection
        function updateShapeSettings() {
            const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
            const cylinderSettings = document.querySelector('.grade-selection:has(#cylinder_diameter_mm)');
            
            // Always show cylinder dimensions in expert mode
            if (cylinderSettings) {
                cylinderSettings.style.display = 'block';
            }
            
            // Initialize cylinder height with current card height when cylinder is selected
            if (shapeType === 'cylinder') {
                const cardHeight = document.getElementById('card_height').value;
                const cylinderHeightInput = document.getElementById('cylinder_height_mm');
                if (cylinderHeightInput) {
                    cylinderHeightInput.value = cardHeight;
                }
                checkCylinderOverflow();
            }
        }
        
        // Function to check cylinder text overflow
        function checkCylinderOverflow() {
            const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
            if (shapeType !== 'cylinder') return;
            
            const diameter = parseFloat(document.getElementById('cylinder_diameter_mm').value) || 30;
            const height = parseFloat(document.getElementById('cylinder_height_mm').value) || 52;
            const cellSpacing = parseFloat(document.getElementById('cell_spacing').value) || 6.5;
            const dotSpacing = parseFloat(document.getElementById('dot_spacing').value) || 2.5;
            const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10;
            
            // Calculate how many cells fit around circumference
            // cellSpacing is the center-to-center distance between cells
            const circumference = Math.PI * diameter;
            const cellsPerRow = Math.floor(circumference / cellSpacing);
            
            // Calculate how many rows fit on cylinder
            const rowsOnCylinder = Math.floor(height / lineSpacing);
            
            // Get total cells needed from text
            const lines = getDynamicLineValues();
            let totalCellsNeeded = 0;
            lines.forEach(line => {
                if (line.trim()) {
                    totalCellsNeeded += line.trim().length;
                }
            });
            
            const totalCellsAvailable = cellsPerRow * rowsOnCylinder;
            
            const warningDiv = document.getElementById('cylinder-overflow-warning');
            const warningMessage = document.getElementById('cylinder-overflow-message');
            
            if (totalCellsNeeded > totalCellsAvailable) {
                warningMessage.textContent = `Text requires ${totalCellsNeeded} cells but cylinder can fit ${totalCellsAvailable} cells. Some text may be cut off.`;
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }

        // Function to create dynamic line inputs based on grid_rows value
        function createDynamicLineInputs(numLines) {
            const container = document.getElementById('dynamic-line-inputs');
            container.innerHTML = ''; // Clear existing inputs
            
            for (let i = 1; i <= numLines; i++) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'line-input';
                lineDiv.innerHTML = `
                    <label for="line${i}" class="line-label">Line ${i}</label>
                    <input type="text" id="line${i}" name="line${i}" placeholder="Enter English text here..." maxlength="50" aria-describedby="line${i}-help">
                    <span id="line${i}-help" class="sr-only">Maximum 50 characters for line ${i}</span>
                `;
                container.appendChild(lineDiv);
            }
            
            // Re-add event listeners for the new inputs
            addInputChangeListeners();
        }

        // Function to collect all dynamic line values
        function getDynamicLineValues() {
            const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
            const lines = [];
            for (let i = 1; i <= gridRows; i++) {
                const input = document.getElementById(`line${i}`);
                lines.push(input ? input.value : '');
            }
            // Ensure we always return at least 4 lines for backend compatibility
            while (lines.length < 4) {
                lines.push('');
            }
            return lines;
        }

        // Function to add listener for grid_rows changes
        function addGridRowsListener() {
            const gridRowsInput = document.getElementById('grid_rows');
            if (gridRowsInput) {
                gridRowsInput.addEventListener('input', () => {
                    const numLines = parseInt(gridRowsInput.value) || 4;
                    // Clamp to reasonable limits
                    const clampedLines = Math.max(1, Math.min(10, numLines));
                    if (clampedLines !== numLines) {
                        gridRowsInput.value = clampedLines;
                    }
                    createDynamicLineInputs(clampedLines);
                    resetToGenerateState();
                });
            }
        }
        
        // Initialize dynamic line inputs and listeners
        createDynamicLineInputs(4); // Start with default 4 lines
        addInputChangeListeners();
        addGridRowsListener();
        
        // Initialize shape settings to show/hide cylinder parameters correctly
        updateShapeSettings();

        expertToggleBtn.addEventListener('click', () => {
            const isVisible = expertSettings.style.display !== 'none';
            expertSettings.style.display = isVisible ? 'none' : 'block';
            expertToggleText.textContent = isVisible ? 'Show Expert Mode' : 'Hide Expert Mode';
            expertToggleIcon.textContent = isVisible ? '▼' : '▲';
            expertToggleBtn.classList.toggle('active', !isVisible);
        });

        infoToggleBtn.addEventListener('click', () => {
            const isVisible = infoContent.style.display !== 'none';
            infoContent.style.display = isVisible ? 'none' : 'block';
                                        infoToggleText.textContent = isVisible ? 'More Info' : 'Hide Information';
            infoToggleIcon.textContent = isVisible ? '▼' : '▲';
            infoToggleBtn.classList.toggle('active', !isVisible);
        });

        // Add real-time debugging for Expert Mode parametric dials
        const expertInputs = [
            'emboss_dot_base_diameter',
            'emboss_dot_height', 
            'emboss_dot_flat_hat',
            'grid_columns',
            'grid_rows',
            'cell_spacing',
            'line_spacing',
            'dot_spacing',
            'card_width',
            'card_height',
            'card_thickness',
            'braille_x_adjust',
            'braille_y_adjust',
            'cylinder_diameter_mm',
            'cylinder_height_mm',
            'cylinder_polygonal_cutout_radius_mm',
            'seam_offset_deg'
        ];
        
        expertInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', (e) => {
                    log.debug(`Expert Mode Input Changed: ${inputId} = ${e.target.value}`);
                });
                
                // Also log the initial values
                log.debug(`Initial value for ${inputId}: ${input.value}`);
            }
        });
        
        // Function to get current Expert Mode values
        window.getCurrentExpertModeValues = function() {
            const values = {};
            expertInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    values[inputId] = input.value;
                }
            });
            return values;
        };

        // Preview braille translation using real liblouis
        previewBrailleBtn.addEventListener('click', async () => {
            // Reset button state when previewing (user is making changes)
            resetToGenerateState();
            const lines = getDynamicLineValues();
            
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;
            
            if (lines.every(line => !line.trim())) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }

            errorDiv.style.display = 'none';
            let previewHTML = '';
            
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim()) {
                    try {
                        // Use real liblouis translation with selected table
                        const braille = await translateWithLiblouis(lines[i].trim(), 'g2', tableName);
                        previewHTML += `<div class="preview-line-success">
                            <strong>Line ${i + 1}:</strong> "${lines[i].trim()}" → "${braille}"
                        </div>`;
                    } catch (error) {
                        log.error('Translation failed for line', i + 1, ':', error);
                        previewHTML += `<div class="preview-line-error">
                            <strong>Line ${i + 1}:</strong> "${lines[i].trim()}" → Error: ${error.message}
                        </div>`;
                    }
                }
            }
            
            previewContent.innerHTML = previewHTML;
            braillePreview.style.display = 'block';
        });

        function init3D() {
            // Mobile-optimized renderer settings
            const isMobile = window.innerWidth <= 768;
            renderer = new THREE.WebGLRenderer({ 
                antialias: !isMobile, // Disable antialiasing on mobile for performance
                powerPreference: isMobile ? "low-power" : "high-performance"
            });
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
            viewer.innerHTML = '';
            viewer.appendChild(renderer.domElement);
            
            // Get theme-appropriate colors with proper fallbacks
            const styles = getComputedStyle(document.documentElement);
            const stlBackground = styles.getPropertyValue('--stl-background').trim() || '#f1f5f9';
            const stlAmbientLight = styles.getPropertyValue('--stl-ambient-light').trim() || '#888888';
            const stlDirectionalLight = styles.getPropertyValue('--stl-directional-light').trim() || '#ffffff';
            const stlAmbientIntensity = parseFloat(styles.getPropertyValue('--stl-ambient-intensity').trim()) || 0.5;
            const stlDirectionalIntensity = parseFloat(styles.getPropertyValue('--stl-directional-intensity').trim()) || 1.0;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(stlBackground);
            
            camera = new THREE.PerspectiveCamera(45, viewer.clientWidth/viewer.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 120);
            camera.lookAt(0, 0, 0);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            
            // Mobile-optimized controls
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = isMobile ? 0.5 : 1.0;
            controls.zoomSpeed = isMobile ? 0.8 : 1.2;
            controls.panSpeed = isMobile ? 0.5 : 0.8;
            
            // Touch-specific settings
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            controls.update();
            
            // Theme-appropriate lighting with intensity control
            const directionalLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity);
            
            // Position the directional light for optimal viewing from multiple angles
            // For high contrast mode, use a more balanced lighting position
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'high-contrast') {
                // For high contrast: use multiple light sources for better visibility
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);
                
                // Add a secondary fill light for high contrast mode
                const fillLight = new THREE.DirectionalLight(new THREE.Color(stlDirectionalLight), stlDirectionalIntensity * 0.3);
                fillLight.position.set(-1, -0.5, 0.5).normalize();
                scene.add(fillLight);
            } else {
                // Standard positioning for normal modes
                directionalLight.position.set(0, 0, 1).normalize();
                scene.add(directionalLight);
            }
            
            scene.add(new THREE.AmbientLight(new THREE.Color(stlAmbientLight), stlAmbientIntensity));
            
            // Handle window resize for mobile orientation changes
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            camera.aspect = viewer.clientWidth / viewer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        form.onsubmit = async (e) => {
            e.preventDefault();
            errorDiv.style.display = 'none';
            errorText.textContent = '';
            
            // Collect all dynamic line inputs
            const lines = getDynamicLineValues();
            
            const plateType = document.querySelector('input[name="plate_type"]:checked').value;
            const languageSelect = document.getElementById('language-table');
            const tableName = languageSelect.value;
            
            // Translate text to braille only for positive plates
            let translatedLines = [];
            if (plateType === 'positive') {
                // Translate text to braille before sending to backend
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        try {
                            log.debug(`Translating line ${i + 1}: '${line}' to braille using table: ${tableName}...`);
                            const brailleText = await translateWithLiblouis(line, 'g2', tableName);
                            log.debug(`Line ${i + 1} translated: '${line}' → '${brailleText}'`);
                            translatedLines.push(brailleText);
                        } catch (error) {
                            log.error(`Failed to translate line ${i + 1}:`, error);
                            // Fallback to original text if translation fails
                            translatedLines.push(line);
                        }
                    } else {
                        translatedLines.push('');
                    }
                }
                log.debug('Original lines:', lines);
                log.debug('Translated lines:', translatedLines);
            } else {
                // Counter plates don't need text - just pass empty lines
                translatedLines = ['', '', '', ''];
                log.debug('Counter plate selected - no text translation needed');
            }
            const settings = {
                grid_columns: document.getElementById('grid_columns').value,
                grid_rows: document.getElementById('grid_rows').value,
                cell_spacing: document.getElementById('cell_spacing').value,
                line_spacing: document.getElementById('line_spacing').value,
                dot_spacing: document.getElementById('dot_spacing').value,
                emboss_dot_base_diameter: document.getElementById('emboss_dot_base_diameter').value,
                emboss_dot_height: document.getElementById('emboss_dot_height').value,
                emboss_dot_flat_hat: document.getElementById('emboss_dot_flat_hat').value,
                counter_plate_dot_size_offset: document.getElementById('counter_plate_dot_size_offset').value,
                card_width: document.getElementById('card_width').value,
                card_height: document.getElementById('card_height').value,
                card_thickness: document.getElementById('card_thickness').value,
                braille_x_adjust: document.getElementById('braille_x_adjust').value,
                braille_y_adjust: document.getElementById('braille_y_adjust').value
            };
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Settings object keys:', Object.keys(settings));
            log.debug('Settings object values:', Object.values(settings));
            
            // Check if at least one line has content (only for positive plates)
            if (plateType === 'positive' && lines.every(line => !line.trim())) {
                errorText.textContent = 'Please enter text in at least one line.';
                errorDiv.style.display = 'flex';
                return;
            }
            
            // Validate braille character limits AFTER translation (only for positive plates)
            if (plateType === 'positive') {
                const gridColumns = parseInt(document.getElementById('grid_columns').value);
                for (let i = 0; i < translatedLines.length; i++) {
                    const brailleLine = translatedLines[i];
                    if (brailleLine && brailleLine.length > gridColumns) {
                        const over = brailleLine.length - gridColumns;
                        errorText.textContent = `Line ${i + 1} exceeds ${gridColumns} braille cells by ${over} cells after translation. Please shorten your text.`;
                        errorDiv.style.display = 'flex';
                        errorDiv.className = 'error-message';
                        return;
                    }
                }
            }
            
            // Show loading message
            errorText.textContent = plateType === 'positive' ? 'Translating text to braille...' : 'Generating counter plate...';
            errorDiv.style.display = 'flex';
            errorDiv.className = 'error-message info';
            
            // Update button to show loading state
            actionBtn.disabled = true;
            actionBtn.textContent = 'Generating...';
            actionBtn.style.opacity = '0.7';
            
            // Get shape type and cylinder params
            const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
            let cylinderParams = {};
            
            if (shapeType === 'cylinder') {
                cylinderParams = {
                    diameter_mm: document.getElementById('cylinder_diameter_mm').value,
                    height_mm: document.getElementById('cylinder_height_mm').value,
                    polygonal_cutout_radius_mm: document.getElementById('cylinder_polygonal_cutout_radius_mm').value,
                    seam_offset_deg: document.getElementById('seam_offset_deg').value
                };
            }
            
            // Debug: Log the settings being sent
            log.debug('Expert Mode Settings:', settings);
            log.debug('Shape Type:', shapeType);
            log.debug('Cylinder Params:', cylinderParams);
            
            const res = await fetch('/generate_braille_stl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    lines: translatedLines, 
                    grade: 'g2', 
                    plate_type: plateType, 
                    shape_type: shapeType,
                    cylinder_params: cylinderParams,
                    settings: settings 
                })
            });
            
            // Hide loading message
            errorDiv.style.display = 'none';
            
            if (!res.ok) {
                let msg = 'Error generating STL';
                try {
                    const data = await res.json();
                    if (data.error) msg = data.error;
                } catch (e) {
                    msg = `Server error: ${res.status} ${res.statusText}`;
                }
                errorText.textContent = msg;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
                return;
            }
            
            try {
                // Create blob and URL for 3D preview
                const blob = await res.blob();
                if (lastSTLUrl) URL.revokeObjectURL(lastSTLUrl);
                lastSTLUrl = URL.createObjectURL(blob);
                
                // Generate filename on frontend to match backend logic
                const plateType = document.querySelector('input[name="plate_type"]:checked').value;
                const shapeType = document.querySelector('input[name="shape_type"]:checked').value;
                let filename = plateType === 'positive' ? 'braille_embossing_plate' : 'braille_counter_plate';
                
                if (plateType === 'positive') {
                    // Get the current lines from the form
                    const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const lines = [];
                    for (let i = 1; i <= gridRows; i++) {
                        const input = document.getElementById(`line${i}`);
                        lines.push(input ? input.value : '');
                    }
                    
                    // Find first non-empty line (prioritizing Line 1)
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            // Sanitize filename: remove special characters and limit length
                            let sanitized = lines[i].trim().substring(0, 30);
                            sanitized = sanitized.replace(/[^\w\s-]/g, '');
                            sanitized = sanitized.replace(/[-\s]+/g, '_').replace(/^_+|_+$/g, '');
                            
                            if (sanitized) {
                                filename = `braille_embossing_plate_${sanitized}-${shapeType}`;
                                break;
                            }
                        }
                    }
                    // If no text was found, still append shape type
                    if (!filename.includes(shapeType)) {
                        filename = `braille_embossing_plate-${shapeType}`;
                    }
                } else {
                    // For counter plates, include total diameter (base + offset) in filename
                    const dotDiameter = parseFloat(document.getElementById('emboss_dot_base_diameter').value) || 0;
                    const counterOffset = parseFloat(document.getElementById('counter_plate_dot_size_offset').value) || 0;
                    const totalDiameter = dotDiameter + counterOffset;
                    filename = `braille_counter_plate_${totalDiameter}mm-${shapeType}`;
                }
                
                // Store the generated STL URL and filename for download
                lastGeneratedSTLUrl = lastSTLUrl;
                lastGeneratedFilename = `${filename}.stl`;
                loadSTL(lastSTLUrl);
                
                // Change button to download state after successful generation
                actionBtn.disabled = false;
                setToDownloadState();
            } catch (e) {
                errorText.textContent = 'Failed to process STL file: ' + e.message;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message'; // Reset to error style
                // Re-enable button on error and reset to generate state
                resetToGenerateState();
            }
        };



        function loadSTL(url) {
            init3D();
            const loader = new STLLoader();
            loader.load(url, function (geometry) {
                if (mesh) scene.remove(mesh);
                
                // Compute bounding box before centering to detect object type
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const width = bbox.max.x - bbox.min.x;
                const height = bbox.max.y - bbox.min.y; 
                const depth = bbox.max.z - bbox.min.z;
                
                // Check if this is a cylinder
                const shapeType = document.querySelector('input[name="shape_type"]:checked')?.value;
                const isCylinder = shapeType === 'cylinder' || height > Math.max(width, depth) * 1.5;
                
                if (!isCylinder) {
                    // For cards, center the geometry as before
                    geometry.center();
                } else {
                    // For cylinders, only center X and Y, keep Z positioning
                    // (cylinder base is at Z=0 in the STL)
                    const centerX = (bbox.max.x + bbox.min.x) / 2;
                    const centerY = (bbox.max.y + bbox.min.y) / 2;
                    geometry.translate(-centerX, -centerY, 0);
                }
                
                // Get theme-appropriate mesh color with proper fallback
                const styles = getComputedStyle(document.documentElement);
                const meshColorVar = styles.getPropertyValue('--stl-mesh-color').trim();
                const meshColor = meshColorVar || '#6699cc';
                // Enhanced material for high contrast mode
                const currentTheme = document.documentElement.getAttribute('data-theme');
                let material;
                
                if (currentTheme === 'high-contrast') {
                    // High contrast material with enhanced specular highlights
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0xffffff, // White specular highlights for maximum contrast
                        shininess: 300, // Higher shininess for sharper highlights
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                } else {
                    // Standard material for other themes
                    material = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(meshColor), 
                        specular: 0x111111, 
                        shininess: 200,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = 0;
                scene.add(mesh);
                
                // Adjust camera position based on object type
                if (isCylinder) {
                    // For cylinders: view from the side, centered on braille content
                    const gridRows = parseInt(document.getElementById('grid_rows').value) || 4;
                    const lineSpacing = parseFloat(document.getElementById('line_spacing').value) || 10.0;
                    const topMargin = parseFloat(document.getElementById('braille_y_adjust')?.value || 0) + 8.4; // Default top margin
                    const cylinderHeight = parseFloat(document.getElementById('cylinder_height_mm').value) || height;
                    
                    // Calculate the center of the braille content
                    const brailleHeight = (gridRows - 1) * lineSpacing;
                    // Since cylinder base is at Z=0 and extends upward, calculate from top
                    const brailleCenterZ = cylinderHeight - topMargin - brailleHeight / 2;
                    
                    // Position camera to view from the side (+X direction looking toward origin)
                    camera.position.set(120, 0, brailleCenterZ);
                    camera.lookAt(0, 0, brailleCenterZ);
                    controls.target.set(0, 0, brailleCenterZ);
                } else {
                    // For cards: keep default front view
                    camera.position.set(0, 0, 120);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                }
                controls.update();
                
                animate();
            }, undefined, function (error) {
                errorText.textContent = 'Failed to load STL: ' + error;
                errorDiv.style.display = 'flex';
                errorDiv.className = 'error-message';
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls && controls.update();
            render();
        }
        
        // Initialize liblouis web worker and 3D viewer on page load
        let liblouisWorker = null;
        let liblouisReady = false;
        let workerMessageId = 0;
        let pendingWorkerMessages = new Map();
        
        // Function to send message to worker and get response
        function sendWorkerMessage(type, data = {}) {
            return new Promise((resolve, reject) => {
                if (!liblouisWorker) {
                    reject(new Error('Worker not initialized'));
                    return;
                }
                
                const id = ++workerMessageId;
                pendingWorkerMessages.set(id, { resolve, reject });
                
                liblouisWorker.postMessage({ id, type, data });
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (pendingWorkerMessages.has(id)) {
                        pendingWorkerMessages.delete(id);
                        reject(new Error('Worker message timeout'));
                    }
                }, 10000);
            });
        }
        
        // Mobile-specific utilities
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (event) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, { passive: false });
        
        // Handle mobile keyboard visibility and orientation changes
        if (isMobileDevice()) {
            const inputs = document.querySelectorAll('input[type="text"], input[type="number"], select');
            inputs.forEach(input => {
                input.addEventListener('focus', () => {
                    // Scroll input into view when keyboard appears
                    setTimeout(() => {
                        input.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
            
            // Handle orientation changes to maintain 200% zoom
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        applyFontSize(6); // Reset to 200% on orientation change
                    }
                }, 100);
            });
        }
        
        window.addEventListener('load', async () => {
            try {
                // Initialize liblouis web worker
                log.debug('Initializing liblouis web worker...');
                
                // Test if worker file is accessible first
                try {
                    const workerResponse = await fetch('/static/liblouis-worker.js');
                    if (!workerResponse.ok) {
                        throw new Error(`Worker file not accessible: ${workerResponse.status}`);
                    }
                    log.debug('Worker file is accessible');
                } catch (fetchError) {
                    log.error('Worker file test failed:', fetchError);
                    throw new Error('Cannot access worker file: ' + fetchError.message);
                }
                
                liblouisWorker = new Worker('/static/liblouis-worker.js');
                
                // Handle worker messages
                liblouisWorker.onmessage = function(e) {
                    const { id, type, result } = e.data;
                    
                    if (pendingWorkerMessages.has(id)) {
                        const { resolve, reject } = pendingWorkerMessages.get(id);
                        pendingWorkerMessages.delete(id);
                        
                        if (result.success) {
                            resolve(result);
                        } else {
                            reject(new Error(result.error));
                        }
                    }
                };
                
                liblouisWorker.onerror = function(error) {
                    log.error('Worker error:', error);
                };
                
                // Initialize liblouis in the worker
                const initResult = await sendWorkerMessage('init');
                if (initResult.success) {
                    liblouisReady = true;
                    log.debug('Liblouis web worker initialized successfully');
                } else {
                    throw new Error('Failed to initialize liblouis worker: ' + initResult.error);
                }
                
            } catch (error) {
                log.error('Failed to initialize liblouis worker:', error);
                
                // Fallback: disable liblouis and show error message
                log.debug('Web worker failed - disabling liblouis translation');
                liblouisReady = false;
                liblouisWorker = null;
                
                // Show user that translation is disabled
                const errorDiv = document.getElementById('error-message');
                const errorText = document.getElementById('error-text');
                if (errorDiv && errorText) {
                    errorText.textContent = 'Web worker failed to initialize. Braille translation preview is disabled on this deployment.';
                    errorDiv.style.display = 'flex';
                }
            }
            
            init3D();
            animate();
        });

        // Function to translate text using liblouis web worker
        async function translateWithLiblouis(text, grade, tableName = null) {
            if (!liblouisReady || !liblouisWorker) {
                throw new Error('Liblouis worker not initialized - translation preview unavailable on this deployment');
            }
            
            try {
                log.debug('Sending translation request to worker:', text, 'grade:', grade, 'table:', tableName);
                const result = await sendWorkerMessage('translate', { text, grade, tableName });
                
                if (result.success && result.translation) {
                    log.debug('Translation successful:', result.translation);
                    return result.translation;
                } else {
                    throw new Error('Translation failed: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                log.error('Worker translation failed:', error);
                throw error;
            }
        }




    </script>
</body>
</html> 